<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device Analysis Results - Smart Mobile Doctor</title>
    <meta name="description" content="View your comprehensive mobile device analysis results with AI-powered diagnostics and optimization recommendations.">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/modern-style.css') }}" type="text/css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}" type="text/css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/mobile.css') }}" type="text/css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/result.css') }}" type="text/css">
    <style>
        /* AI Health Diagnosis Styles */
        .ai-health-card {
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        
        .ai-health-card.excellent {
            border-color: #10b981;
            animation: glow-pulse-green 2s ease-in-out infinite;
        }
        
        .ai-health-card.good {
            border-color: #3b82f6;
            animation: glow-pulse-blue 2s ease-in-out infinite;
        }
        
        .ai-health-card.moderate {
            border-color: #f59e0b;
            animation: glow-pulse-yellow 2s ease-in-out infinite;
        }
        
        .ai-health-card.critical {
            border-color: #ef4444;
            animation: glow-pulse-red 2s ease-in-out infinite;
        }
        
        @keyframes glow-pulse-green {
            0%, 100% { box-shadow: 0 0 10px rgba(16, 185, 129, 0.3); }
            50% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.6); }
        }
        
        @keyframes glow-pulse-blue {
            0%, 100% { box-shadow: 0 0 10px rgba(59, 130, 246, 0.3); }
            50% { box-shadow: 0 0 20px rgba(59, 130, 246, 0.6); }
        }
        
        @keyframes glow-pulse-yellow {
            0%, 100% { box-shadow: 0 0 10px rgba(245, 158, 11, 0.3); }
            50% { box-shadow: 0 0 20px rgba(245, 158, 11, 0.6); }
        }
        
        @keyframes glow-pulse-red {
            0%, 100% { box-shadow: 0 0 10px rgba(239, 68, 68, 0.3); }
            50% { box-shadow: 0 0 20px rgba(239, 68, 68, 0.6); }
        }
        
        .health-status-badge {
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: all 0.3s ease;
        }
        
        .health-status-badge.excellent {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }
        
        .health-status-badge.good {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
        }
        
        .health-status-badge.moderate {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
        }
        
        .health-status-badge.critical {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        
        .health-status-badge.unknown {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .ai-health-content {
            position: relative;
            z-index: 1;
        }
        
        /* Live Performance Monitor Styles */
        .live-monitor-card {
            position: relative;
        }
        
        .live-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ef4444;
            display: inline-block;
            animation: pulse-dot 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-dot {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
        
        .gauges-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--space-6);
        }
        
        .gauge-container {
            background: var(--bg-tertiary);
            border-radius: var(--radius-xl);
            padding: var(--space-4);
            transition: transform 0.2s ease;
        }
        
        .gauge-container:hover {
            transform: translateY(-2px);
        }
        
        .gauge-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-3);
        }
        
        .gauge-label {
            font-weight: 600;
            font-size: var(--text-sm);
            color: var(--text-primary);
        }
        
        .gauge-update-time {
            font-size: var(--text-xs);
            color: var(--text-secondary);
        }
        
        .gauge-wrapper {
            position: relative;
            width: 100%;
            padding-bottom: 60%;
        }
        
        .gauge-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .gauge-track {
            stroke-dasharray: 251.2;
            stroke-dashoffset: 0;
        }
        
        .gauge-arc {
            stroke-dasharray: 251.2;
            stroke-dashoffset: 251.2;
            transition: stroke-dashoffset 0.5s ease, stroke 0.3s ease;
            transform-origin: center;
        }
        
        .gauge-value {
            transition: fill 0.3s ease;
        }
        
        .gauge-arc.green {
            stroke: #10b981;
        }
        
        .gauge-arc.yellow {
            stroke: #f59e0b;
        }
        
        .gauge-arc.red {
            stroke: #ef4444;
        }
        
        /* Additional styles for results page */
        .results-hero {
            background: linear-gradient(135deg, var(--primary-600), var(--primary-800));
            color: white;
            padding: var(--space-12) var(--space-6);
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .results-hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="%23ffffff" stroke-width="0.2" opacity="0.3"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>');
            z-index: 0;
        }
        
        .results-hero-content {
            position: relative;
            z-index: 1;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--space-8);
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--space-12) var(--space-6);
        }
        
        @media (min-width: 1024px) {
            .results-grid {
                grid-template-columns: 1fr 400px;
            }
        }
        
        .main-results {
            display: flex;
            flex-direction: column;
            gap: var(--space-6);
        }
        
        .sidebar-results {
            display: flex;
            flex-direction: column;
            gap: var(--space-6);
        }
        
        .result-card {
            background: var(--bg-secondary);
            border-radius: var(--radius-2xl);
            padding: var(--space-8);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-light);
            transition: all var(--transition-normal);
        }
        
        .result-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-xl);
        }
        
        .card-header {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            margin-bottom: var(--space-6);
            padding-bottom: var(--space-4);
            border-bottom: 1px solid var(--border-light);
        }
        
        .card-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--primary-500), var(--primary-700));
            border-radius: var(--radius-xl);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: var(--text-xl);
        }
        
        .status-badge {
            padding: var(--space-1) var(--space-3);
            border-radius: var(--radius-full);
            font-size: var(--text-xs);
            font-weight: var(--font-semibold);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .status-success {
            background: var(--success-100);
            color: var(--success-700);
        }
        
        .status-warning {
            background: var(--warning-100);
            color: var(--warning-700);
        }
        
        .status-error {
            background: var(--error-100);
            color: var(--error-700);
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .data-table th {
            text-align: left;
            padding: var(--space-3) var(--space-4);
            background: var(--bg-tertiary);
            font-weight: var(--font-semibold);
            color: var(--text-secondary);
            font-size: var(--text-sm);
            border-bottom: 1px solid var(--border-light);
        }
        
        .data-table td {
            padding: var(--space-3) var(--space-4);
            border-bottom: 1px solid var(--border-light);
            font-size: var(--text-sm);
        }
        
        .data-table tr:last-child td {
            border-bottom: none;
        }
        
        .uploaded-image-container {
            text-align: center;
            padding: var(--space-4);
            background: var(--bg-tertiary);
            border-radius: var(--radius-xl);
            margin-bottom: var(--space-6);
        }
        
        .uploaded-image-container img {
            max-width: 100%;
            max-height: 400px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
        }
        
        .diagnosis-section {
            display: grid;
            gap: var(--space-6);
        }
        
        .issue-card, .solution-card {
            padding: var(--space-6);
            border-radius: var(--radius-xl);
            border-left: 4px solid;
        }
        
        .issue-card {
            background: var(--error-50);
            border-left-color: var(--error-500);
        }
        
        .solution-card {
            background: var(--success-50);
            border-left-color: var(--success-500);
        }
        
        .qr-section {
            text-align: center;
        }
        
        .qr-display {
            background: var(--bg-tertiary);
            padding: var(--space-8);
            border-radius: var(--radius-2xl);
            margin: var(--space-6) 0;
        }
        
        .qr-display img {
            max-width: 250px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
        }
        
        .action-buttons {
            display: flex;
            gap: var(--space-4);
            justify-content: center;
            flex-wrap: wrap;
            margin-top: var(--space-8);
        }
        
        .btn {
            padding: var(--space-3) var(--space-6);
            border-radius: var(--radius-xl);
            border: none;
            font-weight: var(--font-semibold);
            cursor: pointer;
            transition: all var(--transition-normal);
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            text-decoration: none;
            font-size: var(--text-sm);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary-500), var(--primary-700));
            color: white;
            box-shadow: var(--shadow-md);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-medium);
        }
        
        .btn-secondary:hover {
            background: var(--bg-tertiary);
            transform: translateY(-1px);
        }
        
        .btn-success {
            background: linear-gradient(135deg, var(--success-500), var(--success-700));
            color: white;
            box-shadow: var(--shadow-md);
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
        
        /* Live Battery Widget */
        .live-battery-widget {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-4);
            background: var(--bg-secondary);
            border-radius: var(--radius-xl);
            border: 1px solid var(--border-light);
            font-size: var(--text-sm);
        }
        .battery-icon {
            font-size: var(--text-lg);
        }
        .battery-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .battery-level {
            font-weight: var(--font-semibold);
            color: var(--text-primary);
        }
        .battery-status {
            font-size: var(--text-xs);
            color: var(--text-secondary);
        }
        .battery-last-updated {
            font-size: var(--text-xs);
            color: var(--text-tertiary);
        }
        .battery-live-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #4caf50;
            border-radius: 50%;
            margin-left: 6px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .battery-idle {
            color: var(--text-tertiary);
            font-style: italic;
        }
        
        /* State Chips */
        .state-chip {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-4);
            border-radius: var(--radius-full);
            font-size: var(--text-sm);
            font-weight: var(--font-medium);
        }
        .state-chip.waiting {
            background: var(--warning-100);
            color: var(--warning-700);
        }
        .state-chip.snapshot {
            background: var(--success-100);
            color: var(--success-700);
        }
        .state-chip.live {
            background: var(--primary-100);
            color: var(--primary-700);
        }
        
        /* Source Tags */
        .source-tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: var(--radius-sm);
            font-size: var(--text-xs);
            font-weight: var(--font-medium);
            margin-left: var(--space-2);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        .source-tag.web {
            background: var(--primary-100);
            color: var(--primary-700);
        }
        .source-tag.screenshot {
            background: var(--success-100);
            color: var(--success-700);
        }
        
        /* HTTPS Banner */
        .https-banner {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: var(--radius-lg);
            padding: var(--space-4);
            margin: var(--space-4) var(--space-6);
            font-size: var(--text-sm);
            color: #856404;
        }
        
        /* Recommendations List */
        .recommendations-list {
            list-style: none;
            padding: 0;
            margin: var(--space-4) 0 0 0;
        }
        .recommendations-list li {
            padding: var(--space-2) 0;
            padding-left: var(--space-6);
            position: relative;
        }
        .recommendations-list li:before {
            content: "‚Ä¢";
            position: absolute;
            left: var(--space-2);
            color: var(--primary-600);
            font-weight: bold;
        }
        
        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #323232;
            color: white;
            padding: 16px 24px;
            border-radius: var(--radius-lg);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
            max-width: 90%;
        }
        .toast.show {
            display: block;
            animation: slideUp 0.3s ease;
        }
        .toast.success {
            background: var(--success-600);
        }
        .toast.error {
            background: var(--error-600);
        }
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        
        /* Prediction Styles */
        .prediction-score {
            transition: color 0.3s ease;
        }
        .prediction-score.score-good {
            color: var(--success-600);
        }
        .prediction-score.score-fair {
            color: var(--warning-600);
        }
        .prediction-score.score-poor {
            color: var(--error-600);
        }
        .risk-badge {
            padding: var(--space-2) var(--space-4);
            border-radius: var(--radius-full);
            font-weight: 600;
            display: inline-block;
        }
        .risk-badge.risk-low {
            background: var(--success-100);
            color: var(--success-700);
        }
        .risk-badge.risk-medium {
            background: var(--warning-100);
            color: var(--warning-700);
        }
        .risk-badge.risk-high {
            background: var(--error-100);
            color: var(--error-700);
        }
    </style>
</head>
<body class="animate-fade-in">
    <div class="page-container">
        <nav class="top-nav">
            <div class="nav-content">
                <div class="logo">
                    <i class="fas fa-stethoscope"></i>
                    <span>Smart Mobile Doctor</span>
                </div>
                <div class="nav-actions" style="display: flex; align-items: center; gap: var(--space-4);">
                    {% if session_id %}
                    <div id="live-battery-widget" class="live-battery-widget" style="display: none;">
                        <span class="battery-icon">üîã</span>
                        <div class="battery-info">
                            <div class="battery-level" id="battery-level">--%</div>
                            <div class="battery-status" id="battery-status">--</div>
                            <div class="battery-last-updated" id="battery-last-updated"></div>
                        </div>
                    </div>
                    {% endif %}
                    <a href="{{ url_for('index') }}" class="btn btn-secondary">
                        <i class="fas fa-home"></i>
                        Home
                    </a>
                </div>
            </div>
        </nav>
        
        {% if not is_https %}
        <div class="https-banner">
            ‚ö†Ô∏è <strong>Limited Data Available:</strong> This page is not using HTTPS. Some browser APIs require a secure context. For full functionality, please use HTTPS.
        </div>
        {% endif %}
        
        <div class="results-hero">
            <div class="results-hero-content">
                <h1><i class="fas fa-check-circle"></i> Analysis Complete</h1>
                <p>Your device has been successfully analyzed using our advanced AI diagnostics system.</p>
                {% if session_id %}
                <div style="display: flex; gap: var(--space-3); align-items: center; justify-content: center; flex-wrap: wrap; margin-top: var(--space-4);">
                    <div id="state-chip" class="state-chip waiting">
                        <i class="fas fa-clock"></i>
                        <span>Waiting for phone</span>
                    </div>
                </div>
                {% endif %}
            </div>
                    </div>
                    
        <div class="results-grid">
            <div class="main-results">
                {% if image_path %}
                <div class="result-card animate-slide-up">
                    <div class="card-header">
                        <div class="card-icon">
                            <i class="fas fa-image"></i>
                        </div>
                        <div>
                            <h3>Uploaded Screenshot</h3>
                            <p style="margin: 0; color: var(--text-secondary); font-size: var(--text-sm);">Original device screenshot for analysis</p>
                        </div>
                    </div>
                    <div class="uploaded-image-container">
                        <img src="{{ url_for('static', filename=image_path) }}" alt="Uploaded Device Screenshot">
                    </div>
                            </div>
                {% endif %}
                
                <!-- Parsed About Device Info Panel -->
                {% if is_about_device or device_info %}
                <div id="parsed-about-info-card" class="result-card animate-slide-up" style="animation-delay: 0.05s; margin-top: var(--space-4);">
                    <div class="card-header">
                        <div class="card-icon">
                            <i class="fas fa-clipboard-check"></i>
                        </div>
                        <div>
                            <h3>Parsed About Device Info</h3>
                            <p style="margin: 0; color: var(--text-secondary); font-size: var(--text-sm);">Review and confirm the extracted device information</p>
                        </div>
                    </div>
                    <div id="parsed-about-info-content" style="padding: var(--space-4);">
                        <div id="parsed-fields-container">
                            <!-- Fields will be populated by JavaScript -->
                        </div>
                        <div id="confirm-about-info-actions" style="margin-top: var(--space-4); display: flex; gap: var(--space-3);">
                            <button id="confirm-about-info-btn" class="btn btn-primary" style="flex: 1;">
                                <i class="fas fa-check"></i> Confirm & Calculate Score
                            </button>
                            <button id="edit-about-info-btn" class="btn btn-secondary" style="flex: 1;">
                                <i class="fas fa-edit"></i> Edit
                            </button>
                        </div>
                        <div id="about-info-status" style="margin-top: var(--space-3); padding: var(--space-3); border-radius: var(--radius-md); display: none;">
                            <!-- Status message will be shown here -->
                        </div>
                    </div>
                </div>
                {% endif %}
                
                <div class="result-card animate-slide-up" style="animation-delay: 0.1s">
                    <div class="card-header">
                        <div class="card-icon">
                            <i class="fas fa-microchip"></i>
                        </div>
                        <div>
                            <h3>Device Information</h3>
                            <p style="margin: 0; color: var(--text-secondary); font-size: var(--text-sm);">Extracted hardware and software details</p>
                        </div>
                    </div>
                    <div style="overflow-x: auto;">
                        <table class="data-table">
                            <tbody id="device-info-table">
                            {% if merged_data %}
                                {% for k, v in merged_data.items() %}
                                    {% if k not in ['timestamp', 'source'] %}
                                    <tr>
                                        <th>{{ k | replace('_', ' ') | title }}</th>
                                        <td>
                                            <strong>
                                                {% if v is mapping and 'value' in v %}
                                                    {{ v.value if v.value is not none else 'Not exposed by browser' }}
                                                    {% if v.source %}
                                                    <span class="source-tag {{ v.source }}">{{ v.source }}</span>
                                                    {% endif %}
                                                {% else %}
                                                    {{ v if v is not none else 'Not exposed by browser' }}
                                                {% endif %}
                                            </strong>
                                        </td>
                                    </tr>
                                    {% endif %}
                                {% endfor %}
                            {% else %}
                                {% for k, v in phone_info.items() %}
                                    <tr>
                                        <th>{{ k | replace('_', ' ') | title }}</th>
                                        <td><strong>{{ v }}</strong></td>
                                    </tr>
                                {% endfor %}
                            {% endif %}
                            </tbody>
                        </table>
                        {% if merged_data and merged_data.get('storage') %}
                            {% set storage_val = merged_data.storage.get('value') if merged_data.storage is mapping else merged_data.storage %}
                            {% if storage_val is mapping and storage_val.get('storageSource') == 'browser sandbox' %}
                            <div id="storage-note-static" style="margin-top: var(--space-4); padding: var(--space-3); background: #e3f2fd; border-left: 4px solid #1976d2; border-radius: 4px; font-size: var(--text-sm); color: #1565c0;">
                                <strong>‚ÑπÔ∏è Note:</strong> This shows browser sandbox storage, not full device memory.
                            </div>
                            {% endif %}
                        {% endif %}
                    </div>
                        </div>
                        
                <!-- Live Performance Score Section -->
                <div id="live-performance-card" class="result-card animate-slide-up ai-health-card" style="animation-delay: 0.12s">
                    <div class="card-header">
                        <div class="card-icon">
                            <i class="fas fa-tachometer-alt"></i>
                        </div>
                        <div>
                            <h3>Live Performance Score</h3>
                            <p style="margin: 0; color: var(--text-secondary); font-size: var(--text-sm);">Real-time score based on browser-exposed live metrics</p>
                        </div>
                    </div>
                    <div class="ai-health-content" style="padding: var(--space-6);">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: var(--space-4);">
                            <div>
                                <div style="font-size: var(--text-sm); color: var(--text-secondary); margin-bottom: var(--space-2);">Performance Score</div>
                                <div style="font-size: 2.5rem; font-weight: 700; line-height: 1;">
                                    <span id="health-score-value">--</span>
                                </div>
                            </div>
                            <div id="health-status-badge" class="health-status-badge unknown" style="padding: var(--space-3) var(--space-6); border-radius: var(--radius-full); font-weight: 600; font-size: var(--text-lg);">
                                Analyzing...
                            </div>
                        </div>
                        <div style="padding: var(--space-4); background: rgba(0, 0, 0, 0.05); border-radius: var(--radius-lg); border-left: 4px solid currentColor;">
                            <div style="font-size: var(--text-sm); color: var(--text-secondary); margin-bottom: var(--space-2); font-weight: 600;">üí° Smart Recommendation</div>
                            <div id="health-recommendation" style="font-size: var(--text-base); line-height: 1.6; color: var(--text-primary);">
                                Analyzing device metrics...
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Verified Health Score Section -->
                <div id="verified-score-card" class="result-card animate-slide-up" style="animation-delay: 0.15s; display: none;">
                    <div class="card-header">
                        <div class="card-icon">
                            <i class="fas fa-shield-alt"></i>
                        </div>
                        <div>
                            <h3>Verified Health Score</h3>
                            <p style="margin: 0; color: var(--text-secondary); font-size: var(--text-sm);">Trusted score computed from parsed About device info + live samples</p>
                        </div>
                    </div>
                    <div id="verified-score-content" style="padding: var(--space-6);">
                        <div style="text-align: center; margin-bottom: var(--space-6);">
                            <div style="font-size: var(--text-sm); color: var(--text-secondary); margin-bottom: var(--space-2);">Verified Health Score</div>
                            <div id="verified-score-value" style="font-size: 3.5rem; font-weight: 700; line-height: 1; margin-bottom: var(--space-3);">--</div>
                            <div id="verified-score-label" style="font-size: var(--text-lg); font-weight: 600; display: inline-block; padding: var(--space-2) var(--space-5); border-radius: var(--radius-full);"></div>
                            <div id="verified-score-warning" style="margin-top: var(--space-3); padding: var(--space-2) var(--space-3); background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px; font-size: var(--text-sm); color: #856404; display: none;">
                                <i class="fas fa-exclamation-triangle"></i> Some device info missing ‚Äî score uses conservative estimates
                            </div>
                        </div>
                        <div style="margin-top: var(--space-4); text-align: center;">
                            <button id="show-verified-breakdown-btn" class="btn btn-primary" style="width: 100%;">
                                <i class="fas fa-chart-bar"></i> Show Breakdown
                            </button>
                        </div>
                        <div id="verified-breakdown-panel" style="display: none; margin-top: var(--space-4); padding: var(--space-4); background: var(--bg-secondary); border-radius: var(--radius-lg);">
                            <h4 style="margin-bottom: var(--space-3); font-size: var(--text-base); font-weight: 600;">Component Scores</h4>
                            <div id="verified-breakdown-metrics" style="display: grid; gap: var(--space-3);">
                                <!-- Metrics will be populated by JavaScript -->
                            </div>
                            <div id="verified-raw-fields" style="margin-top: var(--space-4); padding-top: var(--space-4); border-top: 1px solid var(--border-color);">
                                <h4 style="margin-bottom: var(--space-3); font-size: var(--text-base); font-weight: 600;">Parsed About Device Fields</h4>
                                <div id="verified-raw-fields-content" style="display: grid; gap: var(--space-2); font-size: var(--text-sm);">
                                    <!-- Raw fields will be populated by JavaScript -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                        
                <!-- 3-Hour Minute-Resolution Prediction Section -->
                <div class="result-card animate-slide-up" id="prediction-card" style="animation-delay: 0.17s; display: none;">
                    <div class="card-header">
                        <div class="card-icon">
                            <i class="fas fa-crystal-ball"></i>
                        </div>
                        <div style="flex: 1;">
                            <h3>3-Hour Minute-Resolution Prediction</h3>
                            <p style="margin: 0; color: var(--text-secondary); font-size: var(--text-sm);">Short-term battery forecasting based on rolling sample history</p>
                        </div>
                        <div style="display: flex; align-items: center; gap: var(--space-2);">
                            <label style="font-size: var(--text-xs); color: var(--text-secondary); display: flex; align-items: center; gap: var(--space-1);">
                                <input type="checkbox" id="prediction-demo-toggle" style="margin: 0;">
                                Demo Mode (60√ó)
                            </label>
                        </div>
                    </div>
                    <div style="padding: var(--space-6);">
                        <!-- Health Score -->
                        <div style="text-align: center; margin-bottom: var(--space-4);">
                            <div style="font-size: var(--text-sm); color: var(--text-secondary); margin-bottom: var(--space-2);">3-Hour Projected Health Score</div>
                            <div id="prediction-health-score" class="prediction-score" style="font-size: 3rem; font-weight: 700; line-height: 1;">--</div>
                        </div>

                        <!-- Status Indicators -->
                        <div style="margin-bottom: var(--space-4); text-align: center;">
                            <div id="prediction-fallback-indicator" style="display: none; padding: var(--space-2) var(--space-4); background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px; font-size: var(--text-xs); color: #856404; margin-bottom: var(--space-2);"></div>
                            <div id="prediction-sample-count" style="font-size: var(--text-xs); color: var(--text-secondary);">Samples: --</div>
                        </div>

                        <!-- Battery Chart -->
                        <div style="margin-bottom: var(--space-6);">
                            <div style="font-size: var(--text-sm); font-weight: 600; margin-bottom: var(--space-2);">Battery Projection (0-180 minutes)</div>
                            <div class="prediction-chart-container" style="height: 300px;">
                                <canvas id="batteryChart" class="prediction-chart"></canvas>
                            </div>
                        </div>

                        <!-- Projected Times -->
                        <div style="margin-bottom: var(--space-6);">
                            <h4 style="font-size: var(--text-base); margin-bottom: var(--space-3);">Projected Times</h4>
                            <ul id="prediction-projected-times" style="list-style: none; padding: 0; margin: 0;">
                                <li style="padding: var(--space-2) 0; color: var(--text-secondary);">Calculating...</li>
                            </ul>
                        </div>

                        <!-- Assumptions/Limits -->
                        <div style="margin-top: var(--space-6); padding: var(--space-3); background: #e3f2fd; border-left: 4px solid #1976d2; border-radius: 4px; font-size: var(--text-xs); color: #1565c0;">
                            <strong>‚ÑπÔ∏è Short-Term Forecasting:</strong> Predictions use recent battery drain trends from the last 6-12 samples (collected every 10-30s). If history is flat or insufficient, we use a conservative fallback estimate (0.01-0.05% per minute). Predictions pause while charging. Real hardware metrics require optional native collector. Predictions update automatically with each new battery reading.
                        </div>
                    </div>
                </div>

                <!-- Insufficient Data Message -->
                <div class="result-card animate-slide-up" id="prediction-insufficient" style="display: none; animation-delay: 0.17s;">
                    <div class="card-header">
                        <div class="card-icon">
                            <i class="fas fa-crystal-ball"></i>
                        </div>
                        <div>
                            <h3>3-Hour Minute-Resolution Prediction</h3>
                            <p style="margin: 0; color: var(--text-secondary); font-size: var(--text-sm);">Short-term battery forecasting</p>
                        </div>
                    </div>
                    <div style="padding: var(--space-6); text-align: center;">
                        <div class="insufficient-message" style="color: var(--text-secondary);">
                            Insufficient data ‚Äî collecting samples. Need at least 2 non-charging samples.
                        </div>
                        <p style="margin-top: var(--space-4); font-size: var(--text-sm); color: var(--text-tertiary);">
                            The collector samples battery every 10-30s. Predictions will appear once enough data is collected.
                        </p>
                    </div>
                </div>

                <!-- Charging Paused Message -->
                <div class="result-card animate-slide-up" id="prediction-charging" style="display: none; animation-delay: 0.17s;">
                    <div class="card-header">
                        <div class="card-icon">
                            <i class="fas fa-plug"></i>
                        </div>
                        <div>
                            <h3>3-Hour Minute-Resolution Prediction</h3>
                            <p style="margin: 0; color: var(--text-secondary); font-size: var(--text-sm);">Predictions paused while charging</p>
                        </div>
                    </div>
                    <div style="padding: var(--space-6); text-align: center;">
                        <div class="charging-message" style="color: var(--text-secondary);">
                            Predictions paused while device is charging.
                        </div>
                        <p style="margin-top: var(--space-4); font-size: var(--text-sm); color: var(--text-tertiary);">
                            Battery predictions will resume automatically when charging stops.
                        </p>
                    </div>
                </div>

                <!-- Live Performance Monitor Section -->
                <div class="result-card animate-slide-up live-monitor-card" style="animation-delay: 0.18s">
                    <div class="card-header">
                        <div class="card-icon">
                            <i class="fas fa-tachometer-alt"></i>
                        </div>
                        <div style="flex: 1;">
                            <h3>Live Performance Monitor</h3>
                            <p style="margin: 0; color: var(--text-secondary); font-size: var(--text-sm);">Real-time performance metrics and responsiveness</p>
                        </div>
                        <div style="display: flex; align-items: center; gap: var(--space-2);">
                            <span id="live-monitor-status" class="live-dot" style="display: none;"></span>
                            <button id="toggle-monitor-btn" class="btn btn-primary" style="padding: var(--space-2) var(--space-4); font-size: var(--text-sm);">
                                <i class="fas fa-play"></i> Start Live Monitor
                            </button>
                        </div>
                    </div>
                    <div id="live-monitor-content" style="display: none; padding: var(--space-6);">
                        <div class="gauges-grid">
                            <!-- Battery Gauge -->
                            <div class="gauge-container">
                                <div class="gauge-header">
                                    <span class="gauge-label">Battery Level</span>
                                    <span id="battery-gauge-last-update" class="gauge-update-time"></span>
                                </div>
                                <div class="gauge-wrapper">
                                    <svg class="gauge-svg" viewBox="0 0 200 120">
                                        <defs>
                                            <linearGradient id="batteryGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                                <stop offset="0%" style="stop-color:#10b981;stop-opacity:1" />
                                                <stop offset="70%" style="stop-color:#f59e0b;stop-opacity:1" />
                                                <stop offset="90%" style="stop-color:#ef4444;stop-opacity:1" />
                                            </linearGradient>
                                        </defs>
                                        <path class="gauge-track" d="M 20 100 A 80 80 0 0 1 180 100" fill="none" stroke="#e5e7eb" stroke-width="12"/>
                                        <path id="battery-gauge-arc" class="gauge-arc" d="M 20 100 A 80 80 0 0 1 180 100" fill="none" stroke="url(#batteryGradient)" stroke-width="12" stroke-linecap="round"/>
                                        <text id="battery-gauge-value" class="gauge-value" x="100" y="75" text-anchor="middle" font-size="24" font-weight="700" fill="var(--text-primary)">--%</text>
                                        <text class="gauge-label-text" x="100" y="95" text-anchor="middle" font-size="12" fill="var(--text-secondary)">Battery</text>
                                    </svg>
                                </div>
                            </div>
                            
                            <!-- Storage Gauge -->
                            <div class="gauge-container">
                                <div class="gauge-header">
                                    <span class="gauge-label">Storage Usage (Browser Sandbox)</span>
                                    <span id="storage-gauge-last-update" class="gauge-update-time"></span>
                                </div>
                                <div class="gauge-wrapper" title="Browser sandbox storage (not full device storage)">
                                    <svg class="gauge-svg" viewBox="0 0 200 120">
                                        <defs>
                                            <linearGradient id="storageGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                                <stop offset="0%" style="stop-color:#10b981;stop-opacity:1" />
                                                <stop offset="70%" style="stop-color:#f59e0b;stop-opacity:1" />
                                                <stop offset="90%" style="stop-color:#ef4444;stop-opacity:1" />
                                            </linearGradient>
                                        </defs>
                                        <path class="gauge-track" d="M 20 100 A 80 80 0 0 1 180 100" fill="none" stroke="#e5e7eb" stroke-width="12"/>
                                        <path id="storage-gauge-arc" class="gauge-arc" d="M 20 100 A 80 80 0 0 1 180 100" fill="none" stroke="url(#storageGradient)" stroke-width="12" stroke-linecap="round"/>
                                        <text id="storage-gauge-value" class="gauge-value" x="100" y="75" text-anchor="middle" font-size="24" font-weight="700" fill="var(--text-primary)" title="Browser sandbox storage (not full device storage)">--%</text>
                                        <text class="gauge-label-text" x="100" y="95" text-anchor="middle" font-size="12" fill="var(--text-secondary)">Sandbox Storage</text>
                                    </svg>
                                </div>
                            </div>
                            
                            <!-- Responsiveness Gauge -->
                            <div class="gauge-container">
                                <div class="gauge-header">
                                    <span class="gauge-label">Responsiveness</span>
                                    <span id="responsiveness-gauge-last-update" class="gauge-update-time"></span>
                                </div>
                                <div class="gauge-wrapper">
                                    <svg class="gauge-svg" viewBox="0 0 200 120">
                                        <defs>
                                            <linearGradient id="responsivenessGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                                <stop offset="0%" style="stop-color:#10b981;stop-opacity:1" />
                                                <stop offset="70%" style="stop-color:#f59e0b;stop-opacity:1" />
                                                <stop offset="90%" style="stop-color:#ef4444;stop-opacity:1" />
                                            </linearGradient>
                                        </defs>
                                        <path class="gauge-track" d="M 20 100 A 80 80 0 0 1 180 100" fill="none" stroke="#e5e7eb" stroke-width="12"/>
                                        <path id="responsiveness-gauge-arc" class="gauge-arc" d="M 20 100 A 80 80 0 0 1 180 100" fill="none" stroke="url(#responsivenessGradient)" stroke-width="12" stroke-linecap="round"/>
                                        <text id="responsiveness-gauge-value" class="gauge-value" x="100" y="75" text-anchor="middle" font-size="24" font-weight="700" fill="var(--text-primary)">--</text>
                                        <text class="gauge-label-text" x="100" y="95" text-anchor="middle" font-size="12" fill="var(--text-secondary)">Index</text>
                                    </svg>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                        
                <div class="result-card animate-slide-up" style="animation-delay: 0.2s">
                    <div class="card-header">
                        <div class="card-icon">
                            <i class="fas fa-stethoscope"></i>
                        </div>
                        <div>
                            <h3>AI Diagnosis</h3>
                            <p style="margin: 0; color: var(--text-secondary); font-size: var(--text-sm);">Comprehensive analysis and recommendations</p>
                                </div>
                    </div>
                    <div class="diagnosis-section">
                        <div class="issue-card">
                            <h4 style="color: var(--error-700); margin-bottom: var(--space-3); display: flex; align-items: center; gap: var(--space-2);">
                                <i class="fas fa-exclamation-triangle"></i>
                                Detected Issues
                            </h4>
                            <p style="margin: 0; line-height: var(--leading-relaxed);">{{ issue }}</p>
                            </div>
                            
                        <div class="solution-card">
                            <h4 style="color: var(--success-700); margin-bottom: var(--space-3); display: flex; align-items: center; gap: var(--space-2);">
                                <i class="fas fa-lightbulb"></i>
                                Recommended Solutions
                            </h4>
                            <p style="margin: 0; line-height: var(--leading-relaxed);">{{ solution }}</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
            <div class="sidebar-results">
                <div class="result-card animate-slide-up" style="animation-delay: 0.3s">
                    <div class="card-header">
                        <div class="card-icon">
                            <i class="fas fa-qrcode"></i>
                        </div>
                        <div>
                            <h3>Advanced Diagnostics</h3>
                            <p style="margin: 0; color: var(--text-secondary); font-size: var(--text-sm);">Get deeper insights</p>
                        </div>
                    </div>
                    <div class="qr-section">
                        <p style="margin-bottom: var(--space-6); color: var(--text-secondary);">Generate a QR code to collect additional diagnostic data directly from your device.</p>
                        <button id="generateQRBtn" class="btn btn-primary">
                            <i class="fas fa-qrcode"></i>
                            Generate QR Code
                        </button>
                        <div id="qrCodeDisplay" class="qr-display" style="display: none;">
                            <img id="qrCodeImage" alt="QR Code for Advanced Diagnostics">
                            <p style="margin-top: var(--space-4); font-size: var(--text-sm); color: var(--text-secondary);">Scan with your device for detailed analysis</p>
                            </div>
                        </div>
                    </div>

        
        <div style="text-align: center; padding: var(--space-12) var(--space-6);">
            <div class="action-buttons">
                <a href="{{ url_for('index') }}" class="btn btn-success">
                    <i class="fas fa-plus"></i>
                    Analyze Another Device
                </a>
                <button class="btn btn-secondary" onclick="window.print()">
                    <i class="fas fa-print"></i>
                    Print Results
                </button>
                {% if session_id %}
                <button class="btn btn-secondary" onclick="recheckData()" id="recheck-btn">
                    <i class="fas fa-sync-alt"></i>
                    Recheck Data
                </button>
                {% endif %}
                {% if session_id %}
                <div style="display: flex; gap: var(--space-3); flex-wrap: wrap;">
                    <button class="btn btn-secondary" id="download-health-report-btn" onclick="downloadHealthReport()">
                        <i class="fas fa-file-pdf"></i>
                        Download Health Report (PDF)
                    </button>
                    <button class="btn btn-primary" id="share-report-btn" onclick="shareReport()">
                        <i class="fas fa-share-alt"></i>
                        Share Report
                    </button>
                </div>
                <div id="share-url-container" style="display: none; margin-top: var(--space-4); padding: var(--space-3); background: #f0f0f0; border-radius: 8px;">
                    <label style="font-size: var(--text-sm); font-weight: 600; margin-bottom: var(--space-2); display: block;">Share URL:</label>
                    <div style="display: flex; gap: var(--space-2);">
                        <input type="text" id="share-url-input" readonly style="flex: 1; padding: var(--space-2); border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: var(--text-sm);">
                        <button class="btn btn-secondary" onclick="copyShareUrl()" style="padding: var(--space-2) var(--space-4);">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <p id="share-expires" style="margin-top: var(--space-2); font-size: var(--text-xs); color: var(--text-secondary);"></p>
                </div>
                {% else %}
                <button class="btn btn-secondary" onclick="downloadResults()">
                    <i class="fas fa-download"></i>
                    Download Report
                </button>
                {% endif %}
                    </div>
                </div>
            </div>


    <!-- Template Data -->
    <script>
        // Feature flag for 12-hour time format (set to false to disable)
        window.USE_12H_FORMAT = true;  // Default: enabled
    </script>
    <script src="{{ url_for('static', filename='js/time-utils.js') }}"></script>
    <script src="{{ url_for('static', filename='js/smart_diagnosis.js') }}"></script>
    <script src="{{ url_for('static', filename='js/prediction.js') }}"></script>
    <script type="application/json" id="template-data">
        {
            "phoneInfo": {{ phone_info | tojson | safe }},
            "issue": {{ issue | tojson | safe }},
            "solution": {{ solution | tojson | safe }},
            "performanceScore": {{ performance_score | tojson | safe }}
        }
    </script>

    <div id="toast" class="toast"></div>

    <script>
        // Get sessionId from page (should be set by server)
        const sessionId = '{{ session_id }}' || null;
        window.sessionId = sessionId;  // Make available to prediction.js
        const templateDataElement = document.getElementById('template-data');
        const templateDataPayload = templateDataElement ? JSON.parse(templateDataElement.textContent) : {
            phoneInfo: {},
            issue: null,
            solution: null,
            performanceScore: null
        };
        const templatePhoneInfo = templateDataPayload.phoneInfo || {};
        window.templateDataPayload = templateDataPayload;
        const mergedDataPayload = {{ merged_data | tojson | safe if merged_data else 'null' }};
        window.mergedDeviceData = mergedDataPayload && mergedDataPayload !== 'null' ? mergedDataPayload : null;
        let latestPerformanceScore = typeof templateDataPayload.performanceScore === 'number'
            ? templateDataPayload.performanceScore
            : parseFloat(templateDataPayload.performanceScore) || null;
        let eventSource = null;
        let currentSnapshot = null;
        let currentLive = null;
        const isSecure = window.location.protocol === 'https:';
        let hasReceivedSnapshot = false;
        let lastBatteryUpdateTime = null;
        let batteryIdleTimer = null;
        
        console.log('[DASHBOARD] SessionId:', sessionId);

        // Toast notification
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast show ${type}`;
            setTimeout(() => {
                toast.className = 'toast';
            }, 3000);
        }

        // Update state chip
        function updateStateChip(state) {
            const chip = document.getElementById('state-chip');
            if (!chip) return;
            
            chip.className = `state-chip ${state}`;
            if (state === 'waiting') {
                chip.innerHTML = '<i class="fas fa-clock"></i><span>Waiting for phone</span>';
            } else if (state === 'snapshot') {
                chip.innerHTML = '<i class="fas fa-check-circle"></i><span>Snapshot received</span>';
            } else if (state === 'live') {
                chip.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i><span>Live updating‚Ä¶</span>';
            }
        }

        // Format time as hh:mm:ss
        function formatTime(date) {
            return date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        // Update battery widget with exact format
        function updateBatteryWidget(batteryData, isLive = false) {
            const widget = document.getElementById('live-battery-widget');
            if (!widget) return;

            let level = null;
            let charging = false;

            if (batteryData) {
                if (batteryData.level !== undefined) {
                    level = batteryData.level;
                    charging = batteryData.charging || false;
                } else if (batteryData.battery && batteryData.battery.level !== undefined) {
                    level = batteryData.battery.level;
                    charging = batteryData.battery.charging || false;
                }
            }

            if (level !== null && level !== undefined) {
                // Update level with exact integer format
                document.getElementById('battery-level').textContent = `${level}%`;
                
                // Update status with exact format and LIVE dot
                const statusEl = document.getElementById('battery-status');
                const statusText = charging ? 'Charging' : 'Not charging';
                statusEl.innerHTML = statusText + (isLive ? '<span class="battery-live-dot"></span>' : '');
                
                // Update last updated time
                const now = new Date();
                lastBatteryUpdateTime = now;
                document.getElementById('battery-last-updated').textContent = `Last updated ${formatTime(now)}`;
                document.getElementById('battery-last-updated').className = 'battery-last-updated';
                
                widget.style.display = 'inline-flex';
                
                // Clear idle timer and set new one
                if (batteryIdleTimer) {
                    clearTimeout(batteryIdleTimer);
                }
                batteryIdleTimer = setTimeout(() => {
                    showBatteryIdle();
                }, 60000); // 60 seconds
                
                // Recompute performance score on battery event
                if (currentSnapshot && isLive) {
                    currentSnapshot.battery = { level: level, charging: charging };
                    recomputePerformanceScore(currentSnapshot);
                }
            }
        }

        // Show battery idle state
        function showBatteryIdle() {
            const statusEl = document.getElementById('battery-status');
            const lastUpdatedEl = document.getElementById('battery-last-updated');
            if (statusEl && lastUpdatedEl) {
                statusEl.innerHTML = '<span class="battery-idle">Phone idle/disconnected</span>';
                lastUpdatedEl.textContent = lastBatteryUpdateTime ? `Last updated ${formatTime(lastBatteryUpdateTime)}` : 'No updates';
                lastUpdatedEl.className = 'battery-last-updated battery-idle';
            }
        }

        // Recompute performance score (client-side version matching server logic)
        function recomputePerformanceScore(data) {
            function parseNumeric(text, defaultVal = 0) {
                if (!text || text === 'Unknown') return defaultVal;
                if (typeof text === 'number') return text;
                const match = String(text).match(/(\d+(?:\.\d+)?)/);
                return match ? parseFloat(match[1]) : defaultVal;
            }

            function clamp(v, lo, hi) {
                return Math.max(lo, Math.min(hi, v));
            }

            // RAM
            let ram_gb = 0;
            if (data.deviceMemory) ram_gb = parseNumeric(data.deviceMemory);
            else if (data.ram) ram_gb = parseNumeric(data.ram);
            else if (data.ramSizeGB) ram_gb = parseNumeric(data.ramSizeGB);

            let ram_score = 0;
            if (ram_gb <= 2) ram_score = clamp((ram_gb / 2.0) * 30, 0, 30);
            else if (ram_gb <= 4) ram_score = 30 + ((ram_gb - 2) / 2.0) * 20;
            else if (ram_gb <= 6) ram_score = 50 + ((ram_gb - 4) / 2.0) * 20;
            else if (ram_gb <= 8) ram_score = 70 + ((ram_gb - 6) / 2.0) * 15;
            else ram_score = 85 + clamp(((ram_gb - 8) / 4.0) * 15, 0, 15);
            ram_score = clamp(ram_score, 0, 100);

            // Storage - use sandbox format if available, otherwise fallback to quota/usage
            let storage_score = 50;
            if (data.storage && typeof data.storage === 'object') {
                let free_pct = 0;
                // Use new sandbox format if available
                if (data.storage.storageSandboxQuotaMB !== undefined && data.storage.storageSandboxUsedMB !== undefined) {
                    const quotaMB = data.storage.storageSandboxQuotaMB;
                    const usedMB = data.storage.storageSandboxUsedMB;
                    if (quotaMB > 0) {
                        free_pct = ((quotaMB - usedMB) / quotaMB) * 100;
                    }
                } else if (data.storage.quota) {
                    // Fallback to old format
                    const quota = data.storage.quota;
                    const usage = data.storage.usage || 0;
                    if (quota > 0) {
                        free_pct = ((quota - usage) / quota) * 100;
                    }
                }
                
                if (free_pct > 0) {
                    if (free_pct < 20) storage_score = (free_pct / 20.0) * 40;
                    else if (free_pct < 40) storage_score = 40 + ((free_pct - 20) / 20.0) * 30;
                    else if (free_pct < 60) storage_score = 70 + ((free_pct - 40) / 20.0) * 20;
                    else storage_score = 90 + clamp(((free_pct - 60) / 40.0) * 10, 0, 10);
                }
            }
            storage_score = clamp(storage_score, 0, 100);

            // Battery
            let battery_score = 50;
            if (data.battery && data.battery.level !== undefined) {
                battery_score = parseFloat(data.battery.level);
                if (data.battery.charging) {
                    battery_score = Math.min(100, battery_score + 5);
                }
            }
            battery_score = clamp(battery_score, 0, 100);

            // OS
            let os_score = 50;
            const os_version = data.os_version || data.androidVersion || data.platform;
            if (os_version) {
                const version_num = parseNumeric(os_version);
                if (version_num > 0) {
                    if (String(os_version).toLowerCase().includes('android') || version_num < 20) {
                        os_score = clamp(((version_num - 8) / 6.0) * 100, 0, 100);
                    } else {
                        os_score = clamp(((version_num - 12) / 5.0) * 100, 0, 100);
                    }
                }
            }
            os_score = clamp(os_score, 0, 100);

            // Weighted average
            const performance_score = Math.round(
                0.30 * ram_score +
                0.30 * storage_score +
                0.20 * battery_score +
                0.20 * os_score
            );

            // Update UI
            const scoreEl = document.getElementById('performance-score-value');
            const labelEl = document.getElementById('performance-label');
            if (scoreEl) {
                scoreEl.textContent = `${clamp(performance_score, 0, 100)}%`;
            }
            if (labelEl) {
                let label = 'Unknown';
                if (performance_score >= 85) label = 'Excellent';
                else if (performance_score >= 70) label = 'Good';
                else if (performance_score >= 50) label = 'Fair';
                else label = 'Poor';
                labelEl.textContent = label;
            }

            console.log('[DASHBOARD] Performance score recomputed:', performance_score);
            latestPerformanceScore = clamp(performance_score, 0, 100);
            renderDeviceAgeCard();
            document.dispatchEvent(new CustomEvent('device-age-recompute'));
        }

        // Update device info table
        function updateDeviceInfoTable(snapshot) {
            const tbody = document.getElementById('device-info-table');
            if (!tbody || !snapshot) return;

            // Clear existing rows
            tbody.innerHTML = '';

            const fields = [
                { key: 'manufacturer', label: 'Manufacturer' },
                { key: 'model', label: 'Model' },
                { key: 'platform', label: 'Platform' },
                { key: 'deviceMemory', label: 'RAM', format: (v) => {
                    if (!v) return null;
                    return `~${v} GB (browser approx)`;
                }},
                { key: 'hardwareConcurrency', label: 'CPU Threads' },
                { key: 'screenWidth', label: 'Screen Width', format: (v) => v ? `${v}px` : null },
                { key: 'screenHeight', label: 'Screen Height', format: (v) => v ? `${v}px` : null },
                { key: 'pixelRatio', label: 'Pixel Ratio' },
                { key: 'battery', label: 'Battery', format: (v) => {
                    if (!v || v.level === undefined) return null;
                    // Exact format: "19% (Charging|Not charging)"
                    return `${v.level}%${v.charging ? ' (Charging)' : ' (Not charging)'}`;
                }},
                { key: 'storage', label: 'Storage (Browser Sandbox)', format: (v) => {
                    if (!v) return null;
                    // Use new sandbox format if available
                    if (v.storageSandboxQuotaMB !== undefined && v.storageSandboxUsedMB !== undefined) {
                        return `Browser Sandbox: ${v.storageSandboxUsedMB} MB used of ${v.storageSandboxQuotaMB} MB (${v.storageSandboxUsagePercent}% used) - Not full device storage`;
                    }
                    // Fallback to old format
                    if (v.quota) {
                        const free = v.quota - v.usage;
                        const freeGB = (free / (1024 * 1024 * 1024)).toFixed(2);
                        const totalGB = (v.quota / (1024 * 1024 * 1024)).toFixed(2);
                        return `Browser Sandbox: ${freeGB} GB free of ${totalGB} GB - Not full device storage`;
                    }
                    return null;
                }},
                { key: 'network', label: 'Network', format: (v) => {
                    if (!v || !v.effectiveType) return null;
                    return `${v.effectiveType}${v.downlink ? ` (${v.downlink} Mbps)` : ''}`;
                }},
                { key: 'gpu', label: 'GPU', format: (v) => {
                    if (!v || !v.vendor) return null;
                    return `${v.vendor} - ${v.renderer}`;
                }}
            ];

            fields.forEach(field => {
                let value = snapshot[field.key];
                let displayValue = '';
                let source = snapshot.source || 'web';

                // Use format function if available
                if (field.format) {
                    displayValue = field.format(value);
                } else if (value === null || value === undefined || value === '') {
                    displayValue = null;
                } else if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                } else {
                    displayValue = String(value);
                }

                // Get reason if value is missing
                let reason = null;
                if (displayValue === null || displayValue === '') {
                    if (field.key === 'battery') {
                        if (!isSecure) {
                            reason = 'Insecure context (enable HTTPS)';
                        } else {
                            reason = 'Not supported on this browser (use Android Chrome over HTTPS)';
                        }
                    } else {
                        reason = isSecure ? 'Not exposed by browser' : 'Insecure context (enable HTTPS)';
                    }
                }

                const row = document.createElement('tr');
                row.innerHTML = `
                    <th>${field.label}</th>
                    <td>
                        <strong>${displayValue || reason || 'Storage info not available'}</strong>
                        ${source ? `<span class="source-tag ${source}">${source}</span>` : ''}
                    </td>
                `;
                tbody.appendChild(row);
            });

            // Show/hide storage note based on data
            const tableContainer = tbody.closest('div');
            let storageNote = document.getElementById('storage-note-dynamic');
            if (snapshot.storage && snapshot.storage.storageSource === 'browser sandbox') {
                if (!storageNote && tableContainer) {
                    storageNote = document.createElement('div');
                    storageNote.id = 'storage-note-dynamic';
                    storageNote.style.cssText = 'margin-top: var(--space-4); padding: var(--space-3); background: #e3f2fd; border-left: 4px solid #1976d2; border-radius: 4px; font-size: var(--text-sm); color: #1565c0;';
                    storageNote.innerHTML = '<strong>‚ÑπÔ∏è Note:</strong> This shows browser sandbox storage, not full device memory.';
                    tableContainer.appendChild(storageNote);
                }
            } else if (storageNote) {
                storageNote.remove();
            }
        }

        function formatBytes(bytes) {
            if (!bytes || bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // Load initial snapshot from API
        async function loadSnapshot() {
            if (!sessionId) {
                console.warn('[DASHBOARD] No sessionId, skipping load');
                return;
            }

            try {
                console.log('[DASHBOARD] Loading snapshot for sessionId:', sessionId);
                const response = await fetch(`/api/session/${sessionId}`);
                const data = await response.json();

                if (data.success) {
                    if (data.snapshot) {
                        currentSnapshot = data.snapshot;
                        updateDeviceInfoTable(data.snapshot);
                        updateBatteryWidget(data.snapshot, false);
                        updateStateChip('snapshot');
                        hasReceivedSnapshot = true;
                        recomputePerformanceScore(data.snapshot);
                        
                        // Update gauges if monitor is active
                        if (monitorActive) {
                            updateAllGauges();
                        }
                        
                        // Update AI Health Diagnosis
                        if (window.SmartDiagnosis && window.SmartDiagnosis.updateSmartDiagnosis) {
                            window.SmartDiagnosis.updateSmartDiagnosis(data.snapshot);
                        }
                        console.log('[DASHBOARD] Snapshot loaded:', data.snapshot);
                    }
                    if (data.live) {
                        currentLive = data.live;
                        updateBatteryWidget(data.live, true);
                        // Update snapshot battery if we have snapshot
                        if (currentSnapshot) {
                            // Update battery in snapshot for AI diagnosis
                            currentSnapshot.battery = {
                                level: data.live.level,
                                charging: data.live.charging
                            };
                            recomputePerformanceScore(currentSnapshot);
                            // Update AI Health Diagnosis with live battery data
                            if (window.SmartDiagnosis && window.SmartDiagnosis.updateSmartDiagnosis) {
                                window.SmartDiagnosis.updateSmartDiagnosis(currentSnapshot);
                            }
                        }
                        console.log('[DASHBOARD] Live data loaded:', data.live);
                    }
                    if (!data.snapshot && !data.live) {
                        updateStateChip('waiting');
                    }
                } else {
                    updateStateChip('waiting');
                }
            } catch (error) {
                console.error('[DASHBOARD] Error loading snapshot:', error);
                updateStateChip('waiting');
            }
        }

        // Subscribe to SSE stream
        function subscribeToStream() {
            if (!sessionId) {
                console.warn('[DASHBOARD] No sessionId, skipping SSE subscription');
                return;
            }

            // Close existing connection if any
            if (eventSource) {
                eventSource.close();
            }

            const streamUrl = `/api/stream/${sessionId}`;
            console.log('[DASHBOARD] Opening SSE stream:', streamUrl);
            eventSource = new EventSource(streamUrl);

            eventSource.onopen = function() {
                console.log('[DASHBOARD] SSE connection opened');
            };

            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    console.log('[DASHBOARD] SSE message received:', data.type);
                    
                    if (data.type === 'connected') {
                        console.log('[DASHBOARD] SSE connected for session:', data.sessionId);
                    } else if (data.type === 'snapshot' && data.data) {
                        // Snapshot update
                        currentSnapshot = data.data;
                        updateDeviceInfoTable(currentSnapshot);
                        updateBatteryWidget(currentSnapshot, false);
                        recomputePerformanceScore(currentSnapshot);
                        
                        // Update gauges if monitor is active
                        if (monitorActive) {
                            updateAllGauges();
                        }
                        
                        // Update AI Health Diagnosis
                        if (window.SmartDiagnosis && window.SmartDiagnosis.updateSmartDiagnosis) {
                            window.SmartDiagnosis.updateSmartDiagnosis(currentSnapshot);
                        }
                        if (!hasReceivedSnapshot) {
                            updateStateChip('snapshot');
                            hasReceivedSnapshot = true;
                            showToast('Device data received', 'success');
                        }
                    } else if (data.type === 'prediction' && data.data) {
                        // Prediction update
                        if (window.PredictionModule && window.PredictionModule.renderPrediction) {
                            window.PredictionModule.renderPrediction(data.data);
                        }
                    } else if (data.type === 'battery' && data.data) {
                        // Live battery update
                        currentLive = data.data;
                        updateBatteryWidget(data.data, true);
                        updateStateChip('live');
                        // Update battery in snapshot if it exists for performance score
                        if (currentSnapshot) {
                            currentSnapshot.battery = {
                                level: data.data.level,
                                charging: data.data.charging
                            };
                            recomputePerformanceScore(currentSnapshot);
                            
                            // Update Battery Gauge if monitor is active
                            if (monitorActive) {
                                updateGauge('battery', data.data.level);
                            }
                            
                            // Update AI Health Diagnosis with new battery data
                            if (window.SmartDiagnosis && window.SmartDiagnosis.updateSmartDiagnosis) {
                                window.SmartDiagnosis.updateSmartDiagnosis(currentSnapshot);
                            }
                        }
                    } else if (data.type === 'verified_score' && data.data) {
                        // Verified score update
                        renderVerifiedScore(data.data);
                    } else if (data.type === 'session:update' && data.data) {
                        // Session update (e.g., About info confirmed)
                        if (data.data.verified_score) {
                            renderVerifiedScore(data.data.verified_score);
                        }
                    }
                } catch (error) {
                    console.error('[DASHBOARD] Error parsing SSE message:', error);
                }
            };

            eventSource.onerror = function(error) {
                console.error('[DASHBOARD] SSE error:', error);
                if (eventSource.readyState === EventSource.CLOSED) {
                    console.log('[DASHBOARD] SSE closed, will reconnect in 3s');
                    // Reconnect after 3 seconds
                    setTimeout(subscribeToStream, 3000);
                }
            };
        }
            
            // QR Code Generation
        // Live Performance Monitor
        let monitorActive = false;
        let gaugeUpdateInterval = null;
        let storageUpdateInterval = null;
        let responsivenessTestInterval = null;
        let lastResponsivenessIndex = 50; // Default value

        // Update gauge arc based on percentage
        function updateGauge(gaugeId, value, isResponsiveness = false) {
            const arc = document.getElementById(`${gaugeId}-gauge-arc`);
            const valueText = document.getElementById(`${gaugeId}-gauge-value`);
            const updateTime = document.getElementById(`${gaugeId}-gauge-last-update`);
            
            if (!arc || !valueText) return;
            
            // Clamp value to 0-100
            const clampedValue = Math.max(0, Math.min(100, value));
            
            // Calculate stroke-dashoffset (251.2 is the circumference of the arc)
            const circumference = 251.2;
            const offset = circumference - (clampedValue / 100) * circumference;
            arc.style.strokeDashoffset = offset;
            
            // Update text
            if (isResponsiveness) {
                valueText.textContent = Math.round(clampedValue);
            } else {
                valueText.textContent = `${Math.round(clampedValue)}%`;
            }
            
            // Update color based on value
            arc.classList.remove('green', 'yellow', 'red');
            if (clampedValue < 70) {
                arc.classList.add('green');
            } else if (clampedValue < 90) {
                arc.classList.add('yellow');
            } else {
                arc.classList.add('red');
            }
            
            // Update timestamp with "Last updated: HH:MM:SS" format
            if (updateTime) {
                const now = new Date();
                updateTime.textContent = `Last updated: ${now.toLocaleTimeString()}`;
            }
        }

        // Responsiveness test: measure time to perform ~10M no-op operations
        function measureResponsiveness() {
            const iterations = 10000000; // 10 million
            const startTime = performance.now();
            
            // Simple no-op loop
            for (let i = 0; i < iterations; i++) {
                // No-op
            }
            
            const endTime = performance.now();
            const duration = endTime - startTime;
            
            // Normalize to 0-100 index (lower duration = higher score)
            // Baseline: 100ms = 100 points, 1000ms = 0 points
            // Formula: 100 - (duration / 10), clamped to 0-100
            let index = 100 - (duration / 10);
            index = Math.max(0, Math.min(100, index));
            
            // Factor in hardwareConcurrency if available
            if (currentSnapshot && currentSnapshot.hardwareConcurrency) {
                const cores = currentSnapshot.hardwareConcurrency;
                // Bonus for more cores: up to +20 points for 8+ cores
                const coreBonus = Math.min(20, (cores / 8) * 20);
                index = Math.min(100, index + coreBonus);
            }
            
            lastResponsivenessIndex = index;
            updateGauge('responsiveness', index, true);
            
            console.log('[MONITOR] Responsiveness test:', {
                duration: `${duration.toFixed(2)}ms`,
                index: Math.round(index)
            });
            
            return index;
        }

        // Update all gauges from current snapshot
        function updateAllGauges() {
            if (!currentSnapshot) return;
            
            // Update Battery Gauge
            if (currentSnapshot.battery && currentSnapshot.battery.level !== undefined) {
                updateGauge('battery', currentSnapshot.battery.level);
            }
            
            // Update Storage Gauge
            if (currentSnapshot.storage) {
                let usagePercent = 0;
                // Prefer new sandbox format
                if (currentSnapshot.storage.storageSandboxUsagePercent !== undefined) {
                    usagePercent = currentSnapshot.storage.storageSandboxUsagePercent;
                } else if (currentSnapshot.storage.quota && currentSnapshot.storage.usage) {
                    // Fallback to old format (bytes)
                    const quota = parseFloat(currentSnapshot.storage.quota);
                    const usage = parseFloat(currentSnapshot.storage.usage);
                    if (!isNaN(quota) && !isNaN(usage) && quota > 0) {
                        usagePercent = (usage / quota) * 100;
                    }
                }
                if (usagePercent > 0) {
                    updateGauge('storage', usagePercent);
                } else {
                    // Show "N/A" in gauge with tooltip
                    const valueText = document.getElementById('storage-gauge-value');
                    if (valueText) {
                        valueText.textContent = 'N/A';
                        valueText.setAttribute('title', 'Browser sandbox storage (not full device storage)');
                    }
                }
            } else {
                // No storage data - show N/A
                const valueText = document.getElementById('storage-gauge-value');
                if (valueText) {
                    valueText.textContent = 'N/A';
                    valueText.setAttribute('title', 'Browser sandbox storage (not full device storage)');
                }
            }
            
            // Responsiveness is updated separately via test
        }

        // Start Live Monitor
        function startLiveMonitor() {
            if (monitorActive) return;
            
            monitorActive = true;
            const btn = document.getElementById('toggle-monitor-btn');
            const content = document.getElementById('live-monitor-content');
            const status = document.getElementById('live-monitor-status');
            
            if (btn) {
                btn.innerHTML = '<i class="fas fa-stop"></i> Stop Live Monitor';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-danger');
            }
            if (content) {
                content.style.display = 'block';
            }
            if (status) {
                status.style.display = 'inline-block';
            }
            
            // Initial update
            updateAllGauges();
            measureResponsiveness();
            
            // Update all gauges every 2 seconds
            gaugeUpdateInterval = setInterval(() => {
                updateAllGauges();
            }, 2000);
            
            // Update storage gauge every 12 seconds (polling interval)
            storageUpdateInterval = setInterval(() => {
                // Helper function to convert bytes to MB
                function bytesToMB(bytes) {
                    if (!bytes || bytes === 0) return 0;
                    return Math.round(bytes / (1024 * 1024));
                }
                
                // Re-fetch storage estimate if possible (only in secure context)
                const isSecure = window.location.protocol === 'https:';
                if (isSecure && navigator.storage && navigator.storage.estimate) {
                    navigator.storage.estimate().then(estimate => {
                        if (currentSnapshot) {
                            const quotaMB = bytesToMB(estimate.quota || 0);
                            const usageMB = bytesToMB(estimate.usage || 0);
                            const usagePercent = quotaMB > 0 ? Math.round((usageMB / quotaMB) * 100) : 0;
                            
                            if (!currentSnapshot.storage) {
                                currentSnapshot.storage = {};
                            }
                            currentSnapshot.storage.storageSandboxUsagePercent = usagePercent;
                            currentSnapshot.storage.storageSandboxQuotaMB = quotaMB;
                            currentSnapshot.storage.storageSandboxUsedMB = usageMB;
                            currentSnapshot.storage.storageSource = "browser-sandbox";
                            // Keep raw values for backward compatibility
                            currentSnapshot.storage.quota = estimate.quota;
                            currentSnapshot.storage.usage = estimate.usage;
                            
                            updateGauge('storage', usagePercent);
                            
                            console.log('[MONITOR] Storage updated:', {
                                usedMB: usageMB,
                                quotaMB: quotaMB,
                                usagePercent: usagePercent,
                                timestamp: new Date().toISOString()
                            });
                            
                            // Update AI Health Diagnosis
                            if (window.SmartDiagnosis && window.SmartDiagnosis.updateSmartDiagnosis) {
                                window.SmartDiagnosis.updateSmartDiagnosis(currentSnapshot);
                            }
                        }
                    }).catch(err => {
                        console.warn('[MONITOR] Storage estimate failed:', err);
                        // Show N/A in gauge
                        const valueText = document.getElementById('storage-gauge-value');
                        if (valueText) {
                            valueText.textContent = 'N/A';
                        }
                    });
                } else {
                    // Not available - show N/A
                    const valueText = document.getElementById('storage-gauge-value');
                    if (valueText) {
                        valueText.textContent = 'N/A';
                    }
                    console.log('[MONITOR] Storage not available:', !isSecure ? 'Insecure context (HTTPS required)' : 'API not supported');
                }
            }, 12000);  // Every 12 seconds
            
            // Run responsiveness test every 5 seconds
            responsivenessTestInterval = setInterval(() => {
                const index = measureResponsiveness();
                
                // Update AI Health Diagnosis with new responsiveness
                if (currentSnapshot && window.SmartDiagnosis && window.SmartDiagnosis.updateSmartDiagnosis) {
                    // Add responsiveness to snapshot temporarily for diagnosis
                    if (!currentSnapshot.responsiveness) {
                        currentSnapshot.responsiveness = {};
                    }
                    currentSnapshot.responsiveness.index = index;
                    window.SmartDiagnosis.updateSmartDiagnosis(currentSnapshot);
                }
            }, 5000);
            
            console.log('[MONITOR] Live monitor started');
        }

        // Stop Live Monitor
        function stopLiveMonitor() {
            if (!monitorActive) return;
            
            monitorActive = false;
            const btn = document.getElementById('toggle-monitor-btn');
            const status = document.getElementById('live-monitor-status');
            
            if (btn) {
                btn.innerHTML = '<i class="fas fa-play"></i> Start Live Monitor';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-primary');
            }
            if (status) {
                status.style.display = 'none';
            }
            
            // Clear all intervals
            if (gaugeUpdateInterval) {
                clearInterval(gaugeUpdateInterval);
                gaugeUpdateInterval = null;
            }
            if (storageUpdateInterval) {
                clearInterval(storageUpdateInterval);
                storageUpdateInterval = null;
            }
            if (responsivenessTestInterval) {
                clearInterval(responsivenessTestInterval);
                responsivenessTestInterval = null;
            }
            
            console.log('[MONITOR] Live monitor stopped');
        }

        // Toggle Live Monitor
        function toggleLiveMonitor() {
            if (monitorActive) {
                stopLiveMonitor();
            } else {
                startLiveMonitor();
            }
        }

        // Retry helper with exponential backoff
        async function fetchWithRetry(url, options = {}, maxRetries = 3) {
            const delays = [1000, 2000, 4000]; // 1s, 2s, 4s
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) {
                        return response;
                    }
                    if (attempt < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delays[attempt]));
                    }
                } catch (error) {
                    if (attempt < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delays[attempt]));
                    } else {
                        throw error;
                    }
                }
            }
            throw new Error('Max retries exceeded');
        }

        // Share Report function with retry logic
        async function shareReport() {
            if (!sessionId) {
                showToast('No session ID available', 'error');
                return;
            }
            
            const btn = document.getElementById('share-report-btn');
            const container = document.getElementById('share-url-container');
            const urlInput = document.getElementById('share-url-input');
            const expiresEl = document.getElementById('share-expires');
            
            if (btn) {
                btn.disabled = true;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Creating...';
            }
            
            try {
                const response = await fetchWithRetry(`/api/share-report/${sessionId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.ok && data.url) {
                    // Show share URL in textbox
                    if (urlInput) {
                        urlInput.value = data.url;
                    }
                    if (expiresEl && data.expires) {
                        const expiresAt = new Date(data.expires);
                        expiresEl.textContent = `Expires: ${expiresAt.toLocaleString()}`;
                    }
                    if (container) {
                        container.style.display = 'block';
                    }
                    
                    // Copy to clipboard
                    try {
                        await navigator.clipboard.writeText(data.url);
                        showToast('Share link created and copied to clipboard!', 'success');
                    } catch (clipboardError) {
                        showToast('Share link created!', 'success');
                    }
                } else {
                    throw new Error(data.error || 'Share link created but server returned non-200');
                }
            } catch (error) {
                console.error('[SHARE] Error:', error);
                showToast(`Failed to create share link: ${error.message}`, 'error');
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-share-alt"></i> Share Report';
                }
            }
        }

        // Copy share URL to clipboard
        function copyShareUrl() {
            const urlInput = document.getElementById('share-url-input');
            if (urlInput && urlInput.value) {
                urlInput.select();
                document.execCommand('copy');
                showToast('Share URL copied to clipboard!', 'success');
            }
        }

        // Download Health Report function with async PDF support
        async function downloadHealthReport() {
            if (!sessionId) {
                showToast('No session ID available', 'error');
                return;
            }
            
            const btn = document.getElementById('download-health-report-btn');
            if (btn) {
                btn.disabled = true;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';
            }
            
            try {
                const response = await fetchWithRetry(`/api/download-health-report/${sessionId}`);
                
                if (response.status === 202) {
                    // Async generation - poll for status
                    const data = await response.json();
                    const token = data.token;
                    
                    if (btn) {
                        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating PDF...';
                    }
                    
                    // Poll for status
                    const pollInterval = setInterval(async () => {
                        try {
                            const statusResponse = await fetch(`/api/report-status/${token}`);
                            const statusData = await statusResponse.json();
                            
                            if (statusData.status === 'ready') {
                                clearInterval(pollInterval);
                                // Download the file
                                window.location.href = `/download-file/${token}`;
                                if (btn) {
                                    btn.disabled = false;
                                    btn.innerHTML = '<i class="fas fa-file-pdf"></i> Download Health Report (PDF)';
                                }
                                showToast('PDF ready! Download starting...', 'success');
                            } else if (statusData.status === 'error') {
                                clearInterval(pollInterval);
                                throw new Error(statusData.error || 'PDF generation failed');
                            }
                        } catch (pollError) {
                            clearInterval(pollInterval);
                            throw pollError;
                        }
                    }, 1000); // Poll every second
                    
                    // Timeout after 60 seconds
                    setTimeout(() => {
                        clearInterval(pollInterval);
                        if (btn) {
                            btn.disabled = false;
                            btn.innerHTML = '<i class="fas fa-file-pdf"></i> Download Health Report (PDF)';
                        }
                        showToast('PDF generation timed out. Please try again.', 'error');
                    }, 60000);
                    
                } else if (response.ok) {
                    // Synchronous generation - download immediately
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `health-report-${sessionId}-${new Date().toISOString().split('T')[0]}.pdf`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    
                    if (btn) {
                        btn.disabled = false;
                        btn.innerHTML = '<i class="fas fa-file-pdf"></i> Download Health Report (PDF)';
                    }
                    showToast('PDF downloaded successfully!', 'success');
                } else {
                    throw new Error(`Server returned ${response.status}`);
                }
            } catch (error) {
                console.error('[DOWNLOAD] Error:', error);
                showToast(`Failed to download report: ${error.message}`, 'error');
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-file-pdf"></i> Download Health Report (PDF)';
                }
            }
        }
        
        // Make functions globally available
        window.shareReport = shareReport;
        window.copyShareUrl = copyShareUrl;
        window.downloadHealthReport = downloadHealthReport;

        document.addEventListener('DOMContentLoaded', function() {
            // Setup Live Monitor toggle button
            const toggleBtn = document.getElementById('toggle-monitor-btn');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleLiveMonitor);
            }
            
            const generateQRBtn = document.getElementById('generateQRBtn');
            if (generateQRBtn) {
                generateQRBtn.addEventListener('click', async function() {
            try {
                this.disabled = true;
                    this.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';
                
                const response = await fetch('/generate_qr');
                    if (!response.ok) throw new Error('Failed to generate QR code');
                    
                const blob = await response.blob();
                const imageUrl = URL.createObjectURL(blob);
                
                    document.getElementById('qrCodeImage').src = imageUrl;
                    document.getElementById('qrCodeDisplay').style.display = 'block';
                    
                    this.innerHTML = '<i class="fas fa-check"></i> QR Code Generated';
                    this.disabled = false;
                        showToast('QR code generated successfully', 'success');
                } catch (error) {
                    console.error('QR generation error:', error);
                    this.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Generation Failed';
                    this.disabled = false;
                        showToast('QR code generation failed', 'error');
                    }
                });
            }

            // Load snapshot and subscribe to stream if session ID exists
            if (sessionId) {
                loadSnapshot().then(() => {
                    subscribeToStream();
                });
            }

            // About Device Info Handling
            const deviceInfo = {{ (device_info | tojson) if device_info else 'null' }};
            const isAboutDevice = {{ 'true' if is_about_device else 'false' }};
            const aboutInfoConfirmed = {{ 'true' if about_info_confirmed else 'false' }};
            
            function renderParsedAboutInfo() {
                const container = document.getElementById('parsed-fields-container');
                if (!container || !deviceInfo) return;
                
                const fields = [
                    { key: 'device_name', label: 'Device Name', type: 'text' },
                    { key: 'model', label: 'Model', type: 'text' },
                    { key: 'manufacturer', label: 'Manufacturer', type: 'text' },
                    { key: 'ram_gb', label: 'RAM (GB)', type: 'number' },
                    { key: 'storage_total_gb', label: 'Storage Total (GB)', type: 'number' },
                    { key: 'storage_used_gb', label: 'Storage Used (GB)', type: 'number' },
                    { key: 'battery_capacity_mah', label: 'Battery Capacity (mAh)', type: 'number' },
                    { key: 'battery_percent', label: 'Battery Percent (%)', type: 'number' },
                    { key: 'os_version', label: 'OS Version', type: 'text' },
                    { key: 'android_api_or_release', label: 'Android API Level', type: 'number' },
                    { key: 'screen_size_cm', label: 'Screen Size (cm)', type: 'number' },
                    { key: 'cpu_model', label: 'CPU Model', type: 'text' },
                    { key: 'camera_info', label: 'Camera Info', type: 'text' }
                ];
                
                const ocrConfidence = deviceInfo.ocr_confidence || {};
                const isEditMode = container.dataset.editMode === 'true';
                
                container.innerHTML = fields.map(field => {
                    const value = deviceInfo[field.key];
                    const confidence = ocrConfidence[field.key] || 0;
                    const isLowConfidence = confidence < 0.80 && value !== null && value !== undefined;
                    const displayValue = value !== null && value !== undefined ? value : '';
                    
                    return `
                        <div class="parsed-field" style="margin-bottom: var(--space-3); padding: var(--space-3); border-radius: var(--radius-md); ${isLowConfidence ? 'background: #fff3cd; border-left: 4px solid #ffc107;' : 'background: var(--bg-secondary);'}">
                            <label style="display: block; font-weight: 600; margin-bottom: var(--space-2); color: var(--text-primary);">
                                ${field.label}
                                ${isLowConfidence ? '<span style="color: #ffc107; font-size: 0.875rem;">(Low Confidence)</span>' : ''}
                                ${confidence > 0 ? `<span style="color: var(--text-secondary); font-size: 0.75rem; font-weight: normal;">(${Math.round(confidence * 100)}%)</span>` : ''}
                            </label>
                            ${isEditMode ? 
                                `<input type="${field.type}" class="form-input" data-field="${field.key}" value="${displayValue}" style="width: 100%; padding: var(--space-2); border: 1px solid var(--border-color); border-radius: var(--radius-sm);">` :
                                `<div style="color: var(--text-primary);">${displayValue || '<em style="color: var(--text-secondary);">Not detected</em>'}</div>`
                            }
                        </div>
                    `;
                }).join('');
            }
            
            async function confirmAboutInfo() {
                const btn = document.getElementById('confirm-about-info-btn');
                const statusDiv = document.getElementById('about-info-status');
                const container = document.getElementById('parsed-fields-container');
                const isEditMode = container.dataset.editMode === 'true';
                
                try {
                    btn.disabled = true;
                    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Confirming...';
                    
                    let confirmedData = {};
                    if (isEditMode) {
                        // Collect edited values
                        const inputs = container.querySelectorAll('input[data-field]');
                        inputs.forEach(input => {
                            const key = input.dataset.field;
                            const value = input.value.trim();
                            if (value) {
                                if (input.type === 'number') {
                                    confirmedData[key] = parseFloat(value) || null;
                                } else {
                                    confirmedData[key] = value;
                                }
                            }
                        });
                    }
                    
                    const response = await fetch(`/api/confirm-about-info/${sessionId}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ confirmed_data: confirmedData })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        statusDiv.style.display = 'block';
                        statusDiv.style.background = '#d4edda';
                        statusDiv.style.color = '#155724';
                        statusDiv.innerHTML = '<i class="fas fa-check-circle"></i> About device info confirmed! Calculating health score...';
                        
                        // Hide confirm/edit buttons
                        document.getElementById('confirm-about-info-actions').style.display = 'none';
                        
                        // Load and display verified score
                        await loadVerifiedScore();
                    } else {
                        throw new Error(result.error || 'Failed to confirm');
                    }
                } catch (error) {
                    console.error('Error confirming About info:', error);
                    statusDiv.style.display = 'block';
                    statusDiv.style.background = '#f8d7da';
                    statusDiv.style.color = '#721c24';
                    statusDiv.innerHTML = `<i class="fas fa-exclamation-circle"></i> Error: ${error.message}`;
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-check"></i> Confirm & Calculate Score';
                }
            }
            
            async function loadVerifiedScore() {
                try {
                    const response = await fetch(`/api/session/${sessionId}/verified-score`);
                    const result = await response.json();
                    
                    if (result.success && result.verified_score) {
                        renderVerifiedScore(result.verified_score);
                        document.dispatchEvent(new CustomEvent('device-age-verified'));
                    }
                } catch (error) {
                    console.error('Error loading verified score:', error);
                }
            }
            
            function renderVerifiedScore(breakdown) {
                const card = document.getElementById('verified-score-card');
                const scoreValue = document.getElementById('verified-score-value');
                const scoreLabel = document.getElementById('verified-score-label');
                const warningDiv = document.getElementById('verified-score-warning');
                const metricsContainer = document.getElementById('verified-breakdown-metrics');
                const rawFieldsContainer = document.getElementById('verified-raw-fields-content');
                
                if (!card || !breakdown) return;
                
                const verifiedScore = breakdown.verified_score || 0;
                let label = 'Unknown';
                let labelClass = '';
                let colorBand = '#6b7280'; // gray
                
                if (verifiedScore >= 80) {
                    label = 'Excellent';
                    labelClass = 'excellent';
                    colorBand = '#10b981'; // green
                } else if (verifiedScore >= 60) {
                    label = 'Good';
                    labelClass = 'good';
                    colorBand = '#3b82f6'; // blue
                } else if (verifiedScore >= 40) {
                    label = 'Moderate';
                    labelClass = 'moderate';
                    colorBand = '#f59e0b'; // yellow
                } else {
                    label = 'Needs Attention';
                    labelClass = 'critical';
                    colorBand = '#ef4444'; // red
                }
                
                scoreValue.textContent = verifiedScore;
                scoreValue.style.color = colorBand;
                scoreLabel.textContent = label;
                scoreLabel.className = `health-status-badge ${labelClass}`;
                scoreLabel.style.display = 'inline-block';
                scoreLabel.style.padding = 'var(--space-2) var(--space-5)';
                scoreLabel.style.borderRadius = 'var(--radius-full)';
                
                // Show warning if missing fields
                if (breakdown.has_missing_fields) {
                    warningDiv.style.display = 'block';
                } else {
                    warningDiv.style.display = 'none';
                }
                
                // Render component scores
                const metrics = [
                    { key: 'battery', label: 'Battery Health', weight: '30%', icon: 'fa-battery-three-quarters' },
                    { key: 'storage', label: 'Storage', weight: '30%', icon: 'fa-hdd' },
                    { key: 'ram_responsiveness', label: 'RAM/Responsiveness', weight: '20%', icon: 'fa-tachometer-alt' },
                    { key: 'os', label: 'OS/Updates', weight: '20%', icon: 'fa-mobile-alt' }
                ];
                
                metricsContainer.innerHTML = metrics.map(metric => {
                    const metricData = breakdown[metric.key] || {};
                    const score = metricData.score || 0;
                    const explanation = metricData.explanation || 'No data available';
                    const usesFallback = metricData.uses_fallback || false;
                    
                    return `
                        <div style="padding: var(--space-3); background: var(--bg-secondary); border-radius: var(--radius-md); ${usesFallback ? 'border-left: 3px solid #ffc107;' : ''}">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-2);">
                                <div style="display: flex; align-items: center; gap: var(--space-2);">
                                    <i class="fas ${metric.icon}" style="color: var(--primary-color);"></i>
                                    <strong>${metric.label}</strong>
                                    <span style="color: var(--text-secondary); font-size: 0.875rem;">(${metric.weight})</span>
                                    ${usesFallback ? '<span style="color: #ffc107; font-size: 0.75rem;" title="Using conservative estimate">‚ö†</span>' : ''}
                                </div>
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--primary-color);">${score.toFixed(1)}</div>
                            </div>
                            <div style="color: var(--text-secondary); font-size: 0.875rem;">${explanation}</div>
                        </div>
                    `;
                }).join('');
                
                // Render raw parsed fields
                if (deviceInfo) {
                    const rawFields = [
                        { key: 'device_name', label: 'Device Name' },
                        { key: 'model', label: 'Model' },
                        { key: 'manufacturer', label: 'Manufacturer' },
                        { key: 'ram_gb', label: 'RAM (GB)' },
                        { key: 'storage_total_gb', label: 'Storage Total (GB)' },
                        { key: 'storage_used_gb', label: 'Storage Used (GB)' },
                        { key: 'battery_capacity_mah', label: 'Battery Capacity (mAh)' },
                        { key: 'battery_percent', label: 'Battery Percent (%)' },
                        { key: 'os_version', label: 'OS Version' },
                        { key: 'android_api_or_release', label: 'Android API Level' },
                        { key: 'screen_size_cm', label: 'Screen Size (cm)' },
                        { key: 'cpu_model', label: 'CPU Model' },
                        { key: 'camera_info', label: 'Camera Info' }
                    ];
                    
                    rawFieldsContainer.innerHTML = rawFields.map(field => {
                        const value = deviceInfo[field.key];
                        return `
                            <div style="display: flex; justify-content: space-between; padding: var(--space-2); border-bottom: 1px solid var(--border-color);">
                                <span style="color: var(--text-secondary);">${field.label}:</span>
                                <strong style="color: var(--text-primary);">${value !== null && value !== undefined ? value : '<em style="color: var(--text-secondary);">Not detected</em>'}</strong>
                            </div>
                        `;
                    }).join('');
                }
                
                card.style.display = 'block';
                
                // Store breakdown for breakdown panel
                window.verifiedScoreBreakdown = breakdown;
                renderDeviceAgeCard();
                document.dispatchEvent(new CustomEvent('device-age-verified'));
            }
            
            const OS_RELEASE_YEARS = {
                android: {
                    "4": 2011,
                    "4.1": 2012,
                    "4.2": 2012,
                    "4.3": 2013,
                    "4.4": 2013,
                    "5": 2014,
                    "5.1": 2015,
                    "6": 2015,
                    "7": 2016,
                    "7.1": 2016,
                    "8": 2017,
                    "8.1": 2017,
                    "9": 2018,
                    "10": 2019,
                    "11": 2020,
                    "12": 2021,
                    "12L": 2022,
                    "13": 2022,
                    "14": 2023,
                    "15": 2024
                },
                ios: {
                    "10": 2016,
                    "11": 2017,
                    "12": 2018,
                    "13": 2019,
                    "14": 2020,
                    "15": 2021,
                    "16": 2022,
                    "17": 2023,
                    "18": 2024
                }
            };
            
            const DEVICE_AGE_DEBUG = window.DEVICE_AGE_DEBUG !== undefined ? window.DEVICE_AGE_DEBUG : true;
            function deviceAgeLog(message, data) {
                if (!DEVICE_AGE_DEBUG) return;
                if (data !== undefined) {
                    console.debug(`[DEVICE_AGE] ${message}`, data);
                } else {
                    console.debug(`[DEVICE_AGE] ${message}`);
                }
            }
            
            const DEVICE_AGE_ALIASES = {
                batteryDesign: [
                    'battery.design_capacity',
                    'battery_capacity_mah',
                    'batteryCapacity',
                    'battery.designCapacity',
                    'battery.specs.capacity',
                    'design_capacity',
                    'designCapacity',
                    'battery.design',
                    'battery.mAh',
                    'battery.mah',
                    'merged_data.battery.design_capacity',
                    'merged_data.battery.designCapacity',
                    'deviceInfo.battery.mAh',
                    'battery.design_capacity',
                    'battery.designCapacity'
                ],
                batteryCurrent: [
                    'battery.current_capacity',
                    'battery.currentCapacity',
                    'battery.capacity.current',
                    'battery_current_capacity',
                    'battery.current',
                    'currentCapacity',
                    'current_capacity',
                    'deviceBattery.current',
                    'battery.level',
                    'battery.percent'
                ],
                batteryPercent: [
                    'battery.level',
                    'batteryPercent',
                    'battery.percent',
                    'battery_percent',
                    'battery_status.percent',
                    'battery.chargePercent'
                ],
                batteryHealthPercent: [
                    'battery.health',
                    'batteryHealth',
                    'battery.healthPercent',
                    'batteryHealthPercent',
                    'battery_health_percent',
                    'health.battery',
                    'battery_state.healthPercent'
                ],
                ram: [
                    'ram_gb',
                    'ramGB',
                    'ram',
                    'ramGb',
                    'deviceMemory',
                    'memory.total',
                    'hardware.ram'
                ],
                performanceScore: [
                    'latestPerformanceScore',
                    'performance_score',
                    'performanceScore',
                    'scores.performance',
                    'diagnostics.performanceScore',
                    'perfScore'
                ],
                responsiveness: [
                    'responsivenessIndex',
                    'responsiveness.index',
                    'responsiveness',
                    'metrics.responsiveness',
                    'diagnostics.responsiveness'
                ],
                storageUsage: [
                    'storageUsagePercent',
                    'storage.usedPercent',
                    'storage.percentUsed',
                    'storageUsage',
                    'storage.percent',
                    'storage.storageSandboxUsagePercent'
                ],
                osVersion: [
                    'merged_data.os.version',
                    'deviceInfo.osVersion',
                    'platform.version',
                    'osVersion',
                    'resultData.os',
                    'device.platform',
                    'device.platformVersion',
                    'device.osVersion',
                    'os.version',
                    'androidVersion',
                    'iosVersion',
                    'merged_data.user_agent',
                    'templatePayload.userAgent',
                    'userAgent'
                ]
            };
            
            function parseNumericValue(value) {
                if (value === null || value === undefined) return null;
                if (typeof value === 'number' && !Number.isNaN(value)) return value;
                const match = String(value).replace(/,/g, '').match(/-?\d+(\.\d+)?/);
                return match ? parseFloat(match[0]) : null;
            }
            
            function clampValue(value, min = 0, max = Number.POSITIVE_INFINITY) {
                if (value === null || value === undefined || Number.isNaN(value)) {
                    return min;
                }
                return Math.max(min, Math.min(max, value));
            }
            
            function resolveDeviceAgePath(obj, path) {
                if (!obj || !path) return undefined;
                if (!path.includes('.')) return obj[path];
                return path.split('.').reduce((acc, key) => {
                    if (acc === undefined || acc === null) return undefined;
                    return acc[key];
                }, obj);
            }
            
            function gatherDeviceAgeSources() {
                const sources = [];
                if (deviceInfo) sources.push({ label: 'deviceInfo', data: deviceInfo });
                if (templatePhoneInfo && Object.keys(templatePhoneInfo).length) {
                    sources.push({ label: 'templatePhoneInfo', data: templatePhoneInfo });
                }
                if (templateDataPayload) {
                    sources.push({ label: 'templatePayload', data: templateDataPayload });
                }
                if (currentSnapshot) sources.push({ label: 'snapshot', data: currentSnapshot });
                if (currentLive) sources.push({ label: 'live', data: currentLive });
                if (window.verifiedScoreBreakdown) {
                    sources.push({ label: 'verifiedScore', data: window.verifiedScoreBreakdown });
                }
                if (window.mergedDeviceData) {
                    sources.push({ label: 'mergedData', data: window.mergedDeviceData });
                }
                return sources;
            }
            
            function gatherAliasValue(sources, aliases, { numeric = true } = {}) {
                for (const alias of aliases) {
                    for (const source of sources) {
                        const raw = resolveDeviceAgePath(source.data, alias);
                        if (raw === undefined || raw === null) continue;
                        const value = numeric ? parseNumericValue(raw) : raw;
                        if (numeric && value === null) continue;
                        return { value, alias, source: source.label, raw };
                    }
                }
                return null;
            }
            
            function estimateFactoryBatteryCapacity(context = {}, fallbackValue = null, ramHint = null) {
                const manufacturer = (context.manufacturer || '').toLowerCase();
                const model = (context.model || '').toLowerCase();
                const combined = `${manufacturer} ${model}`.trim();
                let value = null;
                let source = '';
                
                if (combined.includes('iphone') || manufacturer.includes('apple')) {
                    value = 3200;
                    source = 'Typical iPhone battery spec';
                } else if (combined.includes('pixel')) {
                    value = 4350;
                    source = 'Google Pixel class average';
                } else if (combined.includes('oneplus')) {
                    value = 4500;
                    source = 'OnePlus flagship baseline';
                } else if (combined.includes('galaxy') || manufacturer.includes('samsung')) {
                    value = 4800;
                    source = 'Samsung Galaxy series average';
                } else if (combined.includes('xiaomi') || combined.includes('redmi') || combined.includes('poco')) {
                    value = 5000;
                    source = 'Xiaomi/Redmi typical spec';
                } else if (combined.includes('realme') || combined.includes('oppo') || combined.includes('vivo')) {
                    value = 4800;
                    source = 'BBK ecosystem average';
                } else if (combined.includes('moto') || combined.includes('motorola')) {
                    value = 4200;
                    source = 'Motorola midrange typical';
                } else if (combined.includes('sony') || combined.includes('nokia') || combined.includes('hmd')) {
                    value = 4000;
                    source = 'Legacy Android average';
                }
                
                if (!value && fallbackValue) {
                    value = fallbackValue;
                    source = 'Provided capacity';
                }
                
                if (!value && ramHint !== null) {
                    if (ramHint > 6) {
                        value = 4000;
                        source = `Estimated from ${ramHint}GB RAM profile`;
                    } else if (ramHint >= 4) {
                        value = 3500;
                        source = `Estimated from ${ramHint}GB RAM profile`;
                    } else {
                        value = 3000;
                        source = `Estimated from ${ramHint}GB RAM profile`;
                    }
                }
                
                if (!value) {
                    value = 4200;
                    source = 'Default modern smartphone baseline';
                }
                
                return { value, source, estimated: source !== 'Provided capacity' };
            }
            
            function deriveCurrentCapacity(original, currentValue, healthPercent, levelPercent) {
                if (currentValue) {
                    return { value: currentValue, estimated: false, note: 'Provided current capacity' };
                }
                if (!original) {
                    return { value: null, estimated: true, note: 'Unable to estimate current capacity' };
                }
                if (healthPercent !== null && healthPercent !== undefined) {
                    const pct = clampValue(healthPercent / 100, 0.35, 1);
                    return {
                        value: original * pct,
                        estimated: true,
                        note: 'Estimated from battery health'
                    };
                }
                if (levelPercent !== null && levelPercent !== undefined) {
                    const factor = clampValue(0.65 + (levelPercent / 100) * 0.25, 0.4, 1);
                    return {
                        value: original * factor,
                        estimated: true,
                        note: 'Estimated from charge level'
                    };
                }
                return {
                    value: original * 0.82,
                    estimated: true,
                    note: 'Default capacity wear assumption'
                };
            }
            
            function derivePerformanceScore(perfEntry, respEntry, storageUsage) {
                if (perfEntry && perfEntry.value !== null) {
                    return {
                        value: clampValue(perfEntry.value, 0, 100),
                        estimated: false,
                        note: `Direct score (${perfEntry.alias})`
                    };
                }
                
                const responsiveness = respEntry ? clampValue(respEntry.value, 0, 100) : null;
                const storageComponent = storageUsage !== null ? clampValue(100 - storageUsage, 0, 100) : null;
                
                if (responsiveness === null && storageComponent === null) {
                    return null;
                }
                
                const respScore = responsiveness !== null ? responsiveness : 72;
                const storageScore = storageComponent !== null ? storageComponent : 78;
                
                return {
                    value: clampValue(Math.round(respScore * 0.6 + storageScore * 0.4), 30, 95),
                    estimated: true,
                    note: `Estimated from ${responsiveness !== null ? 'responsiveness' : ''}${responsiveness !== null && storageComponent !== null ? ' & ' : ''}${storageComponent !== null ? 'storage usage' : ''}`
                };
            }
            
            function extractOsFromUserAgent(userAgent) {
                if (!userAgent) return null;
                const ua = String(userAgent).toLowerCase();
                let platform = 'android';
                let version = null;
                
                // iOS detection
                if (ua.includes('iphone os') || ua.includes('iphone') || ua.includes('ipad') || ua.includes('ios')) {
                    platform = 'ios';
                    // Match iOS version: "iPhone OS 13_5" or "OS 13_5" or "Version/13.5"
                    const iosMatch = ua.match(/(?:iphone\s*os|os|version)[\/\s_]+(\d+)[_\.](\d+)/i) || 
                                     ua.match(/(?:iphone\s*os|os|version)[\/\s_]+(\d+)/i);
                    if (iosMatch) {
                        version = iosMatch[2] ? `${iosMatch[1]}.${iosMatch[2]}` : iosMatch[1];
                    }
                } else if (ua.includes('android')) {
                    platform = 'android';
                    // Match Android version: "Android 10" or "Android/10" or "Android 8.1"
                    const androidMatch = ua.match(/android[\/\s]+(\d+(?:\.\d+)?)/i);
                    if (androidMatch) {
                        version = androidMatch[1];
                    }
                }
                
                return version ? { platform, version, raw: userAgent } : null;
            }
            
            function extractOsMetadata(osVersionRaw) {
                if (!osVersionRaw) return null;
                const cleaned = String(osVersionRaw).trim();
                const lower = cleaned.toLowerCase();
                let platform = 'android';
                if (lower.includes('ios') || lower.includes('iphone') || lower.includes('ipad')) {
                    platform = 'ios';
                }
                
                // Aggressive regex extraction: \d+(\.\d+)? to extract major/minor
                let versionMatch = cleaned.match(/\d+(\.\d+)?/);
                let version = versionMatch ? versionMatch[0] : null;
                
                // Handle non-standard formats like "Android Oreo", "Android-8.1", "iOS 13.5"
                if (!version) {
                    // Try patterns like "Android-8.1", "Android 8.1", "iOS 13.5"
                    const altMatch = cleaned.match(/(?:android|ios)[\s\-_]+(\d+(?:\.\d+)?)/i);
                    if (altMatch) {
                        version = altMatch[1];
                    } else {
                        // Try named versions (Oreo = 8, Pie = 9, etc.)
                        const namedVersions = {
                            'oreo': '8', 'pie': '9', 'q': '10', 'r': '11', 's': '12', 'tiramisu': '13', 'upside down cake': '14',
                            'nougat': '7', 'marshmallow': '6', 'lollipop': '5', 'kitkat': '4.4'
                        };
                        for (const [name, ver] of Object.entries(namedVersions)) {
                            if (lower.includes(name)) {
                                version = ver;
                                break;
                            }
                        }
                    }
                }
                
                // If still no version and it looks like a user agent, try user agent extraction
                if (!version && (cleaned.includes('Mozilla') || cleaned.includes('AppleWebKit') || cleaned.includes('Chrome'))) {
                    const uaExtract = extractOsFromUserAgent(cleaned);
                    if (uaExtract) {
                        platform = uaExtract.platform;
                        version = uaExtract.version;
                    }
                }
                
                // Normalize version to major.minor format
                let osMajor = version;
                if (version) {
                    const parts = version.split('.');
                    osMajor = parts[0] + (parts[1] ? '.' + parts[1] : '');
                }
                
                const mapping = OS_RELEASE_YEARS[platform] || {};
                let releaseYear = null;
                if (osMajor && mapping[osMajor]) {
                    releaseYear = mapping[osMajor];
                } else if (osMajor) {
                    const major = osMajor.replace(/[^0-9\.]+/g, '').split('.')[0];
                    if (mapping[major]) {
                        releaseYear = mapping[major];
                    } else {
                        const approx = parseFloat(major);
                        if (!Number.isNaN(approx)) {
                            releaseYear = Math.max(2010, Math.min(new Date().getFullYear(), 2010 + approx));
                        }
                    }
                }
                
                return {
                    platform,
                    version: osMajor || version || cleaned,
                    releaseYear,
                    label: osMajor ? `${platform === 'ios' ? 'iOS' : 'Android'} ${osMajor}` : cleaned,
                    osMajor: osMajor || null
                };
            }
            
            function gatherDeviceAgeInputs() {
                const sources = gatherDeviceAgeSources();
                if (!sources.length) {
                    deviceAgeLog('No sources available for device age computation');
                }
                const aliasUsage = {};
                const noteFallback = [];
                const estimatedFields = new Set();
                const discoveredAliases = [];
                const aliasHelper = (key, aliases, options) => {
                    const entry = gatherAliasValue(sources, aliases, options);
                    if (entry) {
                        aliasUsage[key] = { alias: entry.alias, source: entry.source, raw: entry.raw };
                        discoveredAliases.push({ key, alias: entry.alias, source: entry.source, raw: entry.raw });
                        deviceAgeLog(`Found ${key} via alias "${entry.alias}" from source "${entry.source}"`, { raw: entry.raw });
                    }
                    return entry;
                };
                
                // Aggressive OS version gathering - try all aliases including user agent sources
                let osEntry = aliasHelper('osVersion', DEVICE_AGE_ALIASES.osVersion, { numeric: false });
                
                // Try direct property access as fallback
                if (!osEntry) {
                    for (const source of sources) {
                        if (source.data) {
                            const osVal = source.data.osVersion || source.data.os?.version || 
                                         source.data.platform?.version || source.data.androidVersion || 
                                         source.data.iosVersion || source.data.version ||
                                         source.data.resultData?.os || source.data.device?.platform ||
                                         source.data.device?.platformVersion;
                            if (osVal) {
                                osEntry = { value: osVal, alias: 'direct-property', source: source.label, raw: osVal };
                                aliasUsage['osVersion'] = { alias: 'direct-property', source: source.label, raw: osVal };
                                discoveredAliases.push({ key: 'osVersion', alias: 'direct-property', source: source.label, raw: osVal });
                                deviceAgeLog(`Found OS version via direct property from source "${source.label}"`, { raw: osVal });
                                break;
                            }
                        }
                    }
                }
                
                // Try extracting from user agent strings in sources
                if (!osEntry) {
                    for (const source of sources) {
                        if (source.data) {
                            const ua = source.data.userAgent || source.data.user_agent || 
                                      source.data.merged_data?.user_agent || 
                                      source.data.templatePayload?.userAgent;
                            if (ua) {
                                const uaExtract = extractOsFromUserAgent(ua);
                                if (uaExtract && uaExtract.version) {
                                    osEntry = { value: uaExtract.version, alias: 'user-agent-extract', source: source.label, raw: ua };
                                    aliasUsage['osVersion'] = { alias: 'user-agent-extract', source: source.label, raw: ua };
                                    discoveredAliases.push({ key: 'osVersion', alias: 'user-agent-extract', source: source.label, raw: ua });
                                    deviceAgeLog(`Extracted OS from user agent in source "${source.label}"`, { version: uaExtract.version, platform: uaExtract.platform });
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Try navigator.userAgent as last resort
                if (!osEntry && typeof navigator !== 'undefined' && navigator.userAgent) {
                    const uaExtract = extractOsFromUserAgent(navigator.userAgent);
                    if (uaExtract && uaExtract.version) {
                        osEntry = { value: uaExtract.version, alias: 'navigator.userAgent', source: 'browser', raw: navigator.userAgent };
                        aliasUsage['osVersion'] = { alias: 'navigator.userAgent', source: 'browser', raw: navigator.userAgent };
                        discoveredAliases.push({ key: 'osVersion', alias: 'navigator.userAgent', source: 'browser', raw: navigator.userAgent });
                        deviceAgeLog('Extracted OS from navigator.userAgent', { version: uaExtract.version, platform: uaExtract.platform });
                    }
                }
                
                // Extract OS metadata if we found an OS entry
                let osMetadata = null;
                let osExtracted = null;
                if (osEntry) {
                    osMetadata = extractOsMetadata(osEntry.value);
                    osExtracted = osMetadata?.osMajor || osMetadata?.version || osEntry.value;
                    deviceAgeLog('OS extraction result', { 
                        raw: osEntry.value, 
                        extracted: osExtracted, 
                        releaseYear: osMetadata?.releaseYear,
                        platform: osMetadata?.platform 
                    });
                } else {
                    deviceAgeLog('OS version missing - will use battery+performance fallback');
                }
                
                const manufacturer = (deviceInfo && (deviceInfo.manufacturer || deviceInfo.brand)) ||
                    (templatePhoneInfo && (templatePhoneInfo.manufacturer || templatePhoneInfo.brand)) ||
                    '';
                const model = (deviceInfo && (deviceInfo.model || deviceInfo.device_name)) ||
                    (templatePhoneInfo && (templatePhoneInfo.model || templatePhoneInfo.device_name)) ||
                    '';
                
                const baselineEntry = aliasHelper('batteryDesign', DEVICE_AGE_ALIASES.batteryDesign);
                const currentEntry = aliasHelper('batteryCurrent', DEVICE_AGE_ALIASES.batteryCurrent);
                const percentEntry = aliasHelper('batteryPercent', DEVICE_AGE_ALIASES.batteryPercent);
                const healthEntry = aliasHelper('batteryHealthPercent', DEVICE_AGE_ALIASES.batteryHealthPercent);
                const ramEntry = aliasHelper('ram', DEVICE_AGE_ALIASES.ram);
                const performanceEntry = aliasHelper('performanceScore', DEVICE_AGE_ALIASES.performanceScore);
                const responsivenessEntry = aliasHelper('responsiveness', DEVICE_AGE_ALIASES.responsiveness);
                const storageEntry = aliasHelper('storageUsage', DEVICE_AGE_ALIASES.storageUsage);
                
                const factoryEstimate = estimateFactoryBatteryCapacity(
                    { manufacturer, model },
                    baselineEntry ? baselineEntry.value : null,
                    ramEntry ? ramEntry.value : null
                );
                if (factoryEstimate.estimated) {
                    noteFallback.push(factoryEstimate.source);
                    estimatedFields.add('Factory capacity');
                }
                
                const currentCapacity = deriveCurrentCapacity(
                    factoryEstimate.value,
                    currentEntry ? currentEntry.value : null,
                    healthEntry ? healthEntry.value : null,
                    percentEntry ? percentEntry.value : null
                );
                if (currentCapacity.estimated) {
                    noteFallback.push(currentCapacity.note);
                    estimatedFields.add('Current capacity');
                }
                
                const storageUsage = storageEntry ? clampValue(storageEntry.value, 0, 100) : null;
                const performanceResult = derivePerformanceScore(performanceEntry, responsivenessEntry, storageUsage);
                let performanceScore = performanceResult ? performanceResult.value : latestPerformanceScore;
                if (performanceScore === null || Number.isNaN(performanceScore)) {
                    performanceScore = 75;
                    noteFallback.push('Performance score defaulted to 75');
                    estimatedFields.add('Performance score');
                } else if (performanceResult && performanceResult.estimated) {
                    noteFallback.push(performanceResult.note);
                    estimatedFields.add('Performance score');
                }
                performanceScore = clampValue(performanceScore, 0, 100);
                
                // Mark OS as missing if not found
                if (!osEntry || !osMetadata || !osMetadata.releaseYear) {
                    estimatedFields.add('OS (missing)');
                    noteFallback.push('OS: missing (used battery+perf fallback)');
                }
                
                const estimationMeta = {
                    usedEstimation: estimatedFields.size > 0,
                    estimatedFields: Array.from(estimatedFields),
                    notes: noteFallback.slice(),
                    aliasUsage,
                    osMissing: !osEntry || !osMetadata || !osMetadata.releaseYear
                };
                
                // Adjust weights: increase battery weight when OS is missing
                let weights;
                if (estimationMeta.osMissing) {
                    weights = { os: 0, battery: 0.6, performance: 0.4 };
                } else if (estimationMeta.usedEstimation) {
                    weights = { os: 0.3, battery: 0.5, performance: 0.2 };
                } else {
                    weights = { os: 0.4, battery: 0.4, performance: 0.2 };
                }
                
                deviceAgeLog('Device age alias usage', aliasUsage);
                deviceAgeLog('Device age fallbacks', estimationMeta.notes);
                deviceAgeLog('Discovered aliases', discoveredAliases);
                
                return {
                    osVersion: osEntry ? osEntry.value : null,
                    osMetadata: osMetadata || null,
                    osExtracted: osExtracted || null,
                    originalBattery: factoryEstimate.value,
                    currentBattery: currentCapacity.value,
                    performanceScore,
                    batteryMeta: {
                        measuredBattery: baselineEntry ? baselineEntry.value : null,
                        expectedBattery: factoryEstimate.value,
                        originalSource: factoryEstimate.source,
                        currentSource: currentCapacity.note
                    },
                    estimationMeta,
                    weights,
                    rawSignals: {
                        batteryPercent: percentEntry ? percentEntry.value : null,
                        batteryHealthPercent: healthEntry ? healthEntry.value : null
                    },
                    aliasUsage,
                    discoveredAliases,
                    fallbacksUsed: noteFallback.slice()
                };
            }
            
            function computeDeviceAgeDetails(osVersion, originalBattery, currentBattery, performanceScore, options = {}) {
                // Allow computation even if OS is missing - use battery+performance fallback
                const osMissing = !osVersion || (options.osMetadata && !options.osMetadata.releaseYear);
                
                if (!originalBattery || !currentBattery || performanceScore === null || performanceScore === undefined) {
                    return null;
                }
                
                const osMetadata = osVersion ? (options.osMetadata || extractOsMetadata(osVersion)) : null;
                const ageFromOs = osMetadata && osMetadata.releaseYear 
                    ? clampValue(new Date().getFullYear() - osMetadata.releaseYear, 0, 15)
                    : null;
                
                const batteryDropRate = clampValue((originalBattery - currentBattery) / originalBattery, 0, 0.95);
                const ageFromBattery = batteryDropRate / 0.07;
                const perfScore = clampValue(performanceScore, 0, 100);
                const ageFromPerformance = (100 - perfScore) / 60;
                
                const weights = options.weights || (osMissing ? { os: 0, battery: 0.6, performance: 0.4 } : { os: 0.4, battery: 0.4, performance: 0.2 });
                
                // Compute age: if OS missing, use only battery+performance
                let deviceAge;
                if (osMissing || ageFromOs === null) {
                    deviceAge = (ageFromBattery * weights.battery) + (ageFromPerformance * weights.performance);
                } else {
                    deviceAge = (ageFromOs * weights.os) + (ageFromBattery * weights.battery) + (ageFromPerformance * weights.performance);
                }
                
                deviceAge = Math.max(0.3, deviceAge); // Minimum 0.3 years
                const rounded = Math.round(deviceAge * 10) / 10;
                
                return {
                    formattedAge: `${rounded.toFixed(1)} years`,
                    numericAge: rounded,
                    components: {
                        ageFromOs: ageFromOs !== null ? ageFromOs : null,
                        ageFromBattery,
                        ageFromPerformance,
                        batteryDropRate
                    },
                    osMetadata: osMetadata || null,
                    weights,
                    osMissing: osMissing || false
                };
            }
            
            function calculateDeviceAge(osVersion, originalBattery, currentBattery, performanceScore) {
                const details = computeDeviceAgeDetails(osVersion, originalBattery, currentBattery, performanceScore);
                return details ? details.formattedAge : null;
            }
            window.calculateDeviceAge = calculateDeviceAge;
            
            function showDeviceAgeFallback() {
                const card = document.getElementById('device-age-card');
                const valueEl = document.getElementById('device-age-value');
                const breakdownEl = document.getElementById('device-age-breakdown');
                const badgeEl = document.getElementById('device-age-badge');
                const fallbackEl = document.getElementById('device-age-fallback');
                const estimationNote = document.getElementById('device-age-estimation-note');
                if (!card) return;
                
                card.style.display = 'block';
                if (valueEl) valueEl.textContent = '--';
                if (badgeEl) {
                    badgeEl.textContent = 'Data needed';
                    badgeEl.className = 'health-status-badge unknown';
                }
                if (breakdownEl) {
                    breakdownEl.style.display = 'none';
                    breakdownEl.innerHTML = '';
                }
                if (estimationNote) estimationNote.remove();
                if (fallbackEl) fallbackEl.style.display = 'block';
            }
            
            // Defensive Device Age Renderer: wraps helpers with fallbacks, robust card location, and safe DOM updates.
            // Remove this wrapper if debugging the core device-age logic.
            function renderDeviceAgeCard() {
                // Step 1: Robust card location - try id, then header text variations, then create temp card
                let card = document.getElementById('device-age-card');
                let cardCreated = false;
                if (!card) {
                    const headerTexts = ['estimated device age', 'device age', 'estimated age'];
                    const header = Array.from(document.querySelectorAll('.card-header h3, h3')).find(el => {
                        const text = (el.textContent || '').toLowerCase();
                        return headerTexts.some(ht => text.includes(ht));
                    });
                    if (header) {
                        card = header.closest('.result-card') || header.closest('.animate-slide-up') || header.closest('div');
                    }
                }
                if (!card) {
                    // Create temporary card for demo purposes
                    const mainContainer = document.querySelector('.results-container, .page-container, main, body');
                    if (mainContainer && mainContainer.parentNode) {
                        card = document.createElement('div');
                        card.id = 'device-age-card';
                        card.className = 'result-card animate-slide-up';
                        card.style.animationDelay = '0.16s';
                        card.innerHTML = `
                            <div class="card-header">
                                <div class="card-icon"><i class="fas fa-hourglass-half"></i></div>
                                <div>
                                    <h3>üì± Estimated Device Age</h3>
                                    <p style="margin: 0; color: var(--text-secondary); font-size: var(--text-sm);">AI-based analysis from OS, battery & performance</p>
                                </div>
                            </div>
                            <div id="device-age-content" style="padding: var(--space-6);">
                                <div style="display: flex; align-items: center; justify-content: space-between; gap: var(--space-4);">
                                    <div>
                                        <div style="font-size: var(--text-sm); color: var(--text-secondary); margin-bottom: var(--space-2);">Estimated Device Age</div>
                                        <div id="device-age-value" style="font-size: 3.25rem; font-weight: 700; line-height: 1;">--</div>
                                    </div>
                                    <div id="device-age-badge" class="health-status-badge unknown" style="padding: var(--space-3) var(--space-5); border-radius: var(--radius-full); font-weight: 600; font-size: var(--text-base);">Analyzing...</div>
                                </div>
                                <div id="device-age-breakdown" style="margin-top: var(--space-4); display: none; gap: var(--space-3);"></div>
                                <div id="device-age-fallback" style="margin-top: var(--space-4); padding: var(--space-3); background: #fff3cd; border-left: 4px solid #fbbc05; border-radius: var(--radius-md); font-size: var(--text-sm); color: #7a5a00; display: none;">Not enough data to estimate device age.</div>
                            </div>
                        `;
                        try {
                            const verifiedCard = document.getElementById('verified-score-card');
                            if (verifiedCard && verifiedCard.parentNode) {
                                verifiedCard.parentNode.insertBefore(card, verifiedCard.nextSibling);
                            } else {
                                mainContainer.appendChild(card);
                            }
                        } catch (e) {
                            deviceAgeLog('Failed to insert temp card', e);
                            return;
                        }
                        cardCreated = true;
                        deviceAgeLog('Created temporary device-age card');
                    } else {
                        deviceAgeLog('Cannot create card: no container found');
                        return;
                    }
                }
                
                const valueEl = document.getElementById('device-age-value');
                const breakdownEl = document.getElementById('device-age-breakdown');
                const badgeEl = document.getElementById('device-age-badge');
                const fallbackEl = document.getElementById('device-age-fallback');
                const contentEl = document.getElementById('device-age-content');
                if (!card) return;
                
                // Step 2: Try existing helpers first, then fallback to local computation
                let inputs = null;
                let details = null;
                let helperUsed = 'none';
                let fallbackComputed = false;
                
                try {
                    inputs = gatherDeviceAgeInputs();
                    if (inputs) {
                        helperUsed = 'gatherDeviceAgeInputs';
                        try {
                            details = computeDeviceAgeDetails(
                                inputs.osVersion,
                                inputs.originalBattery,
                                inputs.currentBattery,
                                inputs.performanceScore,
                                { osMetadata: inputs.osMetadata, weights: inputs.weights }
                            );
                            if (details) {
                                helperUsed = 'computeDeviceAgeDetails';
                            }
                        } catch (e) {
                            deviceAgeLog('computeDeviceAgeDetails failed', e);
                        }
                    }
                } catch (e) {
                    deviceAgeLog('gatherDeviceAgeInputs failed', e);
                }
                
                // Step 3: Local fallback computation if helpers returned null - compute even if OS is missing
                if (!details && inputs) {
                    deviceAgeLog('Helpers returned null, computing guaranteed local fallback (OS may be missing)');
                    fallbackComputed = true;
                    try {
                        // Compute using battery+performance even if OS is missing
                        const originalBattery = inputs.originalBattery || 3500; // Default baseline from RAM
                        const currentBattery = inputs.currentBattery || (originalBattery * 0.85); // Default 85% if missing
                        const performanceScore = inputs.performanceScore !== null && inputs.performanceScore !== undefined 
                            ? inputs.performanceScore : 75; // Default 75 if missing
                        
                        const osMetadata = inputs.osMetadata || (inputs.osVersion ? extractOsMetadata(inputs.osVersion) : null);
                        const osMissing = !osMetadata || !osMetadata.releaseYear;
                        
                        const ageFromOs = osMetadata && osMetadata.releaseYear
                            ? clampValue(new Date().getFullYear() - osMetadata.releaseYear, 0, 15)
                            : null;
                        
                        const batteryDropRate = clampValue((originalBattery - currentBattery) / originalBattery, 0, 0.95);
                        const ageFromBattery = batteryDropRate / 0.07;
                        const perfScore = clampValue(performanceScore, 0, 100);
                        const ageFromPerformance = (100 - perfScore) / 60;
                        
                        // Use adaptive weights: increase battery weight when OS is missing
                        const weights = inputs.weights || (osMissing
                            ? { os: 0, battery: 0.6, performance: 0.4 }
                            : (inputs.estimationMeta && inputs.estimationMeta.usedEstimation
                                ? { os: 0.35, battery: 0.45, performance: 0.20 }
                                : { os: 0.4, battery: 0.4, performance: 0.2 }));
                        
                        let deviceAge;
                        if (osMissing || ageFromOs === null) {
                            deviceAge = (ageFromBattery * weights.battery) + (ageFromPerformance * weights.performance);
                        } else {
                            deviceAge = (ageFromOs * weights.os) + (ageFromBattery * weights.battery) + (ageFromPerformance * weights.performance);
                        }
                        deviceAge = Math.max(0.3, deviceAge); // Minimum 0.3 years
                        const rounded = Math.round(deviceAge * 10) / 10;
                        
                        details = {
                            formattedAge: `${rounded.toFixed(1)} years`,
                            numericAge: rounded,
                            components: { ageFromOs, ageFromBattery, ageFromPerformance, batteryDropRate },
                            osMetadata: osMetadata || null,
                            weights,
                            osMissing: osMissing || false
                        };
                        helperUsed = 'local-fallback';
                        deviceAgeLog('Local fallback computed age', { formattedAge: details.formattedAge, osMissing });
                    } catch (e) {
                        console.error('[DEVICE_AGE] Local fallback computation failed', e);
                        deviceAgeLog('Local fallback computation failed', e);
                    }
                }
                
                // Only show "Not enough data" if we truly cannot compute (no battery/performance data)
                if (!inputs || !details) {
                    const reason = !inputs ? 'No data sources available' : 'Computation failed';
                    deviceAgeLog(`Cannot compute age: ${reason}`, { hasInputs: !!inputs, hasDetails: !!details });
                    if (fallbackEl && fallbackEl.parentNode) {
                        fallbackEl.style.display = 'block';
                        fallbackEl.textContent = `Not enough data to estimate device age. ${reason}.`;
                    }
                    if (valueEl && valueEl.parentNode) valueEl.textContent = '--';
                    if (badgeEl && badgeEl.parentNode) {
                        badgeEl.textContent = 'Data needed';
                        badgeEl.className = 'health-status-badge unknown';
                    }
                    return;
                }
                
                const dropPercent = Math.round((details.components.batteryDropRate || 0) * 100);
                const originalBattery = inputs.originalBattery || 3500;
                const batterySource = (inputs.batteryMeta && inputs.batteryMeta.originalSource) || 'estimated';
                const performanceScore = inputs.performanceScore !== null && inputs.performanceScore !== undefined ? inputs.performanceScore : 75;
                const osMissing = details.osMissing || (inputs.estimationMeta && inputs.estimationMeta.osMissing);
                const osLabel = (inputs.osMetadata && inputs.osMetadata.label) || inputs.osVersion || 'Unknown';
                const osReleaseYear = (inputs.osMetadata && inputs.osMetadata.releaseYear) || 'unknown';
                
                // Build breakdown rows - include OS: missing line when OS is missing
                const breakdownRows = [];
                
                if (osMissing || details.components.ageFromOs === null) {
                    breakdownRows.push({
                        label: 'OS recency',
                        value: 'N/A',
                        note: 'OS: missing (used battery+perf fallback)'
                    });
                } else {
                    breakdownRows.push({
                        label: 'OS recency',
                        value: `${details.components.ageFromOs.toFixed(1)} yrs`,
                        note: `${osLabel} ‚Ä¢ Released ${osReleaseYear}`
                    });
                }
                
                breakdownRows.push({
                    label: 'Battery wear',
                    value: `${details.components.ageFromBattery.toFixed(1)} yrs`,
                    note: `${dropPercent}% drop vs ~${Math.round(originalBattery)}mAh baseline (${batterySource})`
                });
                
                breakdownRows.push({
                    label: 'Performance',
                    value: `${details.components.ageFromPerformance.toFixed(1)} yrs`,
                    note: `${Math.round(performanceScore)}% performance score`
                });
                
                // Log which fallbacks were used
                const usedFallbacks = inputs.fallbacksUsed || [];
                if (fallbackComputed) usedFallbacks.push('local-fallback-computation');
                if (osMissing) usedFallbacks.push('os-missing-fallback');
                
                deviceAgeLog('Fallbacks used', usedFallbacks);
                deviceAgeLog('Estimated fields', inputs.estimationMeta ? inputs.estimationMeta.estimatedFields : []);
                deviceAgeLog('Discovered OS aliases', inputs.discoveredAliases || []);
                deviceAgeLog('OS extracted', inputs.osExtracted || null);
                deviceAgeLog('Helper used', helperUsed);
                
                if (valueEl && valueEl.parentNode) valueEl.textContent = details.formattedAge;
                
                // Show DATA ESTIMATED badge if any fallbacks were used or OS is missing
                const showEstimatedBadge = fallbackComputed || (inputs.estimationMeta && inputs.estimationMeta.usedEstimation) || osMissing;
                if (badgeEl && badgeEl.parentNode) {
                    const ageLabel = details.numericAge >= 4 ? 'Aging device' : details.numericAge >= 2.5 ? 'Mature device' : details.numericAge >= 1.2 ? 'Holding up' : 'Fresh hardware';
                    let badgeContent = showEstimatedBadge
                        ? `${ageLabel}<span style="margin-left: 6px; padding: 0.15rem 0.5rem; font-size: 0.65rem; border-radius: 999px; border: 1px solid rgba(0,0,0,0.15); text-transform: uppercase;">DATA ESTIMATED</span>`
                        : ageLabel;
                    badgeEl.innerHTML = badgeContent;
                    badgeEl.className = `health-status-badge ${details.numericAge >= 4 ? 'critical' : details.numericAge >= 2.5 ? 'moderate' : details.numericAge >= 1.2 ? 'good' : 'excellent'}`;
                }
                
                // Step 4: Guard DOM updates - check parentNode before insertBefore, wrap in try-catch
                try {
                    if (fallbackEl && fallbackEl.parentNode) fallbackEl.style.display = 'none';
                    if (card && card.parentNode) card.style.display = 'block';
                    
                    if (contentEl && inputs.estimationMeta && inputs.estimationMeta.usedEstimation) {
                        contentEl.classList.add('device-age-estimation-active');
                    } else if (contentEl) {
                        contentEl.classList.remove('device-age-estimation-active');
                    }
                    
                    // Guard breakdown rendering
                    if (breakdownEl && breakdownEl.parentNode) {
                        breakdownEl.innerHTML = breakdownRows.map(row => `
                            <div class="device-age-factor" style="display: flex; justify-content: space-between; gap: var(--space-3); padding: var(--space-3); background: var(--bg-secondary); border-radius: var(--radius-md); align-items: flex-start;">
                                <div>
                                    <div style="font-weight: 600; color: var(--text-primary);">${row.label}</div>
                                    <div style="font-size: var(--text-sm); color: var(--text-secondary);">${row.note}</div>
                                </div>
                                <div style="font-weight: 700; font-size: var(--text-lg); color: var(--text-primary); text-align: right;">${row.value}</div>
                            </div>
                        `).join('');
                        breakdownEl.style.display = 'grid';
                        
                        // Guard breakdown note insertion - show when any fallbacks were used
                        const existingNote = document.getElementById('device-age-estimation-note');
                        const estimatedFieldsList = (inputs.estimationMeta && inputs.estimationMeta.estimatedFields) || [];
                        if (showEstimatedBadge && estimatedFieldsList.length > 0) {
                            // Build note text with explicit OS missing info
                            let noteParts = [];
                            if (osMissing) {
                                noteParts.push('OS: missing (used battery+perf fallback)');
                            }
                            const otherFields = estimatedFieldsList.filter(f => f !== 'OS (missing)');
                            if (otherFields.length > 0) {
                                noteParts.push(otherFields.join(', '));
                            }
                            const noteText = `DATA ESTIMATED: ${noteParts.join('; ')}`;
                            
                            if (!existingNote) {
                                const noteEl = document.createElement('div');
                                noteEl.id = 'device-age-estimation-note';
                                noteEl.style.padding = 'var(--space-3)';
                                noteEl.style.background = 'rgba(251, 191, 36, 0.15)';
                                noteEl.style.border = '1px dashed rgba(245, 158, 11, 0.4)';
                                noteEl.style.borderRadius = 'var(--radius-md)';
                                noteEl.style.fontSize = 'var(--text-xs)';
                                noteEl.style.fontWeight = '600';
                                noteEl.style.textTransform = 'uppercase';
                                noteEl.style.letterSpacing = '0.05em';
                                noteEl.style.marginTop = 'var(--space-3)';
                                if (breakdownEl.parentNode) {
                                    breakdownEl.appendChild(noteEl);
                                    noteEl.innerHTML = noteText;
                                }
                            } else if (existingNote.parentNode) {
                                existingNote.innerHTML = noteText;
                            }
                        } else if (existingNote && existingNote.parentNode) {
                            existingNote.remove();
                        }
                    }
                } catch (e) {
                    deviceAgeLog('DOM update error (non-fatal)', e);
                }
                
                // Step 5: Build verification summary with helper info and discovered aliases
                const discoveredAliasesList = inputs.discoveredAliases || [];
                const verification = {
                    cardFound: !!card,
                    cardCreated,
                    formattedAge: details.formattedAge,
                    discoveredAliases: discoveredAliasesList,
                    osExtracted: inputs.osExtracted || null,
                    usedFallbacks: usedFallbacks,
                    helperUsed: helperUsed
                };
                
                window.__latestDeviceAgeSummary = {
                    inputs,
                    details,
                    verification
                };
                
                deviceAgeLog('Device age render complete', {
                    helperUsed,
                    fallbackComputed,
                    formattedAge: details.formattedAge,
                    discoveredAliases: discoveredAliasesList.length,
                    usedFallbacks: usedFallbacks.length,
                    osExtracted: inputs.osExtracted || null
                });
                deviceAgeLog('Verification summary', verification);
            }
            
            // Enhanced test function returning full diagnostic object
            window.__testDeviceAge = function(inputs) {
                if (!inputs) {
                    return {
                        formattedAge: null,
                        numericAge: null,
                        components: null,
                        fallbacksUsed: ['no-payload'],
                        error: 'No inputs provided'
                    };
                }
                try {
                    // Use inputs directly if it's already a processed inputs object, otherwise treat as raw payload
                    const osVersion = inputs.osVersion || null;
                    const originalBattery = inputs.originalBattery || 3500;
                    const currentBattery = inputs.currentBattery || (originalBattery * 0.85);
                    const performanceScore = inputs.performanceScore !== null && inputs.performanceScore !== undefined ? inputs.performanceScore : 75;
                    
                    const osMetadata = inputs.osMetadata || (osVersion ? extractOsMetadata(osVersion) : null);
                    const osMissing = !osMetadata || !osMetadata.releaseYear;
                    const weights = inputs.weights || (osMissing ? { os: 0, battery: 0.6, performance: 0.4 } : { os: 0.4, battery: 0.4, performance: 0.2 });
                    
                    const details = computeDeviceAgeDetails(
                        osVersion,
                        originalBattery,
                        currentBattery,
                        performanceScore,
                        {
                            osMetadata: osMetadata,
                            weights: weights
                        }
                    );
                    
                    if (details) {
                        return {
                            formattedAge: details.formattedAge,
                            numericAge: details.numericAge,
                            components: details.components,
                            fallbacksUsed: osMissing ? ['os-missing-fallback'] : [],
                            osMetadata: details.osMetadata,
                            osMissing: details.osMissing || false,
                            weights: details.weights,
                            osExtracted: osMetadata?.osMajor || osMetadata?.version || osVersion || null
                        };
                    } else {
                        return {
                            formattedAge: null,
                            numericAge: null,
                            components: null,
                            fallbacksUsed: ['computation-returned-null'],
                            error: 'computeDeviceAgeDetails returned null'
                        };
                    }
                } catch (e) {
                    return {
                        formattedAge: null,
                        numericAge: null,
                        components: null,
                        fallbacksUsed: ['exception-thrown'],
                        error: e.message || String(e)
                    };
                }
            };
            
            // Lightweight auto-renderer to keep Estimated Device Age card in sync (remove if debugging).
            (function initDeviceAgeAutoRenderer() {
                const MAX_ATTEMPTS = 12;
                let attempts = 0;
                
                function tryRender(reason = 'auto') {
                    const inputs = gatherDeviceAgeInputs();
                    if (!inputs) {
                        deviceAgeLog('auto-render', { reason, status: 'waiting-for-inputs', attempts });
                        return false;
                    }
                    renderDeviceAgeCard();
                    const verification = window.__latestDeviceAgeSummary && window.__latestDeviceAgeSummary.verification;
                    deviceAgeLog('auto-render', { reason, status: 'rendered', verification });
                    return true;
                }
                
                window.__triggerDeviceAgeAutoRender = function(reason = 'manual') {
                    tryRender(reason);
                };
                
                const poll = setInterval(() => {
                    attempts += 1;
                    const hasData = window.mergedDeviceData || (templateDataPayload && Object.keys(templateDataPayload).length) || deviceInfo;
                    if (hasData && tryRender('initial-poll')) {
                        clearInterval(poll);
                    } else if (attempts >= MAX_ATTEMPTS) {
                        clearInterval(poll);
                        deviceAgeLog('auto-render', { reason: 'initial-poll', status: 'max-attempts' });
                    }
                }, 600);
                
                document.addEventListener('device-age-recompute', () => tryRender('performance-update'));
                document.addEventListener('device-age-verified', () => tryRender('verified-score'));
                
                // Watch for latestPerformanceScore changes
                let lastPerformanceScore = window.latestPerformanceScore;
                const performanceScoreWatcher = setInterval(() => {
                    if (window.latestPerformanceScore !== lastPerformanceScore) {
                        lastPerformanceScore = window.latestPerformanceScore;
                        console.log('[DEVICE_AGE] Performance score changed, re-rendering');
                        tryRender('performance-score-change');
                    }
                }, 500);
                
                // Cleanup watcher on page unload
                window.addEventListener('beforeunload', () => {
                    clearInterval(performanceScoreWatcher);
                });
                
                // Run renderer once immediately after initialization
                setTimeout(() => {
                    tryRender('initial-render');
                    const verification = window.__latestDeviceAgeSummary && window.__latestDeviceAgeSummary.verification;
                    if (verification) {
                        console.log('[DEVICE_AGE] Initial render verification:', verification);
                    }
                }, 100);
            })();
            // Initialize About info panel
            if (isAboutDevice && deviceInfo) {
                renderParsedAboutInfo();
                
                const confirmBtn = document.getElementById('confirm-about-info-btn');
                const editBtn = document.getElementById('edit-about-info-btn');
                
                if (confirmBtn) {
                    confirmBtn.addEventListener('click', confirmAboutInfo);
                }
                
                if (editBtn) {
                    editBtn.addEventListener('click', () => {
                        const container = document.getElementById('parsed-fields-container');
                        container.dataset.editMode = container.dataset.editMode === 'true' ? 'false' : 'true';
                        renderParsedAboutInfo();
                    });
                }
                
                // If already confirmed, load verified score
                if (aboutInfoConfirmed) {
                    loadVerifiedScore();
                    document.getElementById('confirm-about-info-actions').style.display = 'none';
                }
            }
            
            // Verified score breakdown panel toggle
            const showBreakdownBtn = document.getElementById('show-verified-breakdown-btn');
            const breakdownPanel = document.getElementById('verified-breakdown-panel');
            if (showBreakdownBtn && breakdownPanel) {
                showBreakdownBtn.addEventListener('click', () => {
                    const isVisible = breakdownPanel.style.display !== 'none';
                    breakdownPanel.style.display = isVisible ? 'none' : 'block';
                    showBreakdownBtn.innerHTML = isVisible 
                        ? '<i class="fas fa-chart-bar"></i> Show Breakdown'
                        : '<i class="fas fa-chevron-up"></i> Hide Breakdown';
                });
            }
            
            // Recheck Data function
            window.recheckData = async function() {
                const btn = document.getElementById('recheck-btn');
                if (btn) {
                    btn.disabled = true;
                    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Rechecking...';
                }
                await loadSnapshot();
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-sync-alt"></i> Recheck Data';
                }
                showToast('Data refreshed', 'success');
            };
            
            // Make downloadResults globally available
            window.downloadResults = function() {
                const templateData = JSON.parse(document.getElementById('template-data').textContent);
                const resultsData = {
                    timestamp: new Date().toISOString(),
                    deviceInfo: templateData.phoneInfo,
                    diagnosis: {
                        issue: templateData.issue,
                        solution: templateData.solution
                    },
                    performanceScore: `${templateData.performanceScore}%`
                };
                
                const dataStr = JSON.stringify(resultsData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `device-analysis-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            };

            renderDeviceAgeCard();
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (eventSource) {
                eventSource.close();
            }
        });
    </script>
</body>
</html>

